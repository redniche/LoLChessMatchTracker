
"""
Point sprites are billboards that are automatically
rotated so that they always face the camera. They are
handy for creating particle effects and explosions.
This sample uses a geometry shader to render points
and "fake" shadows. It is also possible to run
particle simulations on the GPU. You can use 
the mouse and keyboard to control the camera.
"""

import math
import random
import time

import d3d11
import d3d11x
from d3d11c import *

POINT_SIZE = 0.5
POINT_COUNT = 150
GROUND_LEVEL = 0.0
GRAVITY = d3d11.Vector(0, -0.005, 0)

spriteLayoutDesc = [
    ("POSITION", 0, FORMAT_R32G32B32_FLOAT),
    ("COLOR", 0, FORMAT_R32G32B32A32_FLOAT),
    ("PSIZE", 0, FORMAT_R32_FLOAT),
]

class Sprite3D:
    def __init__(self, pos, direction, index):
        self.position = pos
        self.direction = direction
        self.index = index + 1
        
    def toShadowVertex(self):
        #The higer the point, the smaller the shadow. Little hackish solution.
        shadowSize = POINT_SIZE - (self.position.y / 20.0)
        darkness = 0.1
        yPoint = min(GROUND_LEVEL + POINT_SIZE / 2.0, self.position.y - 0.001)
        #Position, RGBA and point size.
        return (self.position.x, yPoint, self.position.z, darkness, darkness, darkness, 1, shadowSize) 
        
    def toVertex(self, isShadow=False):
        #Fade the color based on a x and z distance.
        distance = 10.0 / self.position.distance((0, self.position.y, 0)) 
        indexNorm = float(self.index) / POINT_COUNT
        red = indexNorm * distance
        green = (1.0 - indexNorm) * distance
        blue = indexNorm * distance
        return (self.position.x, self.position.y, self.position.z) + (red, green, blue, 1) + (POINT_SIZE,)


def heightFunc(*args):
    return GROUND_LEVEL

class SpriteSample(d3d11x.Frame):
    def onCreate(self):
        self.heightmap = d3d11x.HeightMap(self.device, None, (32, 32), heightFunc, (2, 1, 2), (10, 10), False)
        self.heightmap.textureView = self.loadTextureView("ground-marble.dds")
        
        effectPath = d3d11x.getResourceDir("Effects", "SampleSprites.fx")
        self.spriteEffect = d3d11.Effect(effectPath)
        self.spriteInputLayout = d3d11.InputLayout(spriteLayoutDesc, self.spriteEffect, 0, 0)
        self.spriteTexture = self.loadTextureView("misc-particle.dds")
        
        self.camera = d3d11x.Camera()
        
        #Create a dynamic vertex buffer for our sprites. Double the
        #size for shadow sprites.
        self.spriteBuffer = d3d11.Buffer(spriteLayoutDesc, POINT_COUNT * 2, 
            BIND_VERTEX_BUFFER, USAGE_DYNAMIC, CPU_ACCESS_WRITE)
        
        self.points = []
        #for i in range(POINT_COUNT):
        #    self.points.append(self.newSprite(i))
        
    def newSprite(self, i):
        pos = d3d11.Vector(0, POINT_SIZE + random.random(), 0)
        #Boost the .y axis slightly.
        direction = d3d11.Vector(0.5 - random.random(), 
            0.5 + random.random(), 0.5 - random.random())
        return Sprite3D(pos, direction.normalize() * 0.25, i)
        
    def onMessage(self, event):
        return self.camera.onMessage(event)
        
    def onUpdate(self):
        self.camera.onUpdate(self.frameTime)
    
        groundHit = GROUND_LEVEL + (POINT_SIZE / 2.0)
    
        #Start filling the list slowly so that there are
        #are no big "pauses" in generation.
        if len(self.points) < POINT_COUNT:
            self.points.append(self.newSprite(len(self.points)))
    
        with d3d11x.Mapper(self.spriteBuffer, MAP_WRITE_DISCARD):
            #First normal sprites.
            for i, point in enumerate(self.points):
                #Add gravity and move the sprite.
                point.direction += GRAVITY
                point.position += point.direction 

                #Append to vertex buffer.
                self.spriteBuffer.append(point.toVertex())

                if point.position.y < groundHit and point.direction.y < 0.0:
                    #Hits the gound, bounce it. Because the ground is a
                    #plane the normal is always (0, 1, 0). Also make
                    #the point lose some of it's speed.
                    point.direction = point.direction.reflect((0, 1, 0)) * 0.5
                    if point.direction.length() < 0.01:
                        #Nearly stopped, replace this one with a new one.
                        self.points[i] = self.newSprite(i)

            #Then add shadow sprites to the buffer.
            for point in self.points:
                self.spriteBuffer.append(point.toShadowVertex())
                    
    def onRender(self):
        viewMatrix = self.camera.getViewMatrix()
        projMatrix = self.createProjection(60, 0.1, 200)
        
        #Heightmap.
        self.heightmap.effect.set("lightAmbient", (0.5, 0.5, 0.5, 0))
        self.heightmap.render(d3d11.Matrix(), viewMatrix, projMatrix)
          
        #Then all sprites.
        self.device.setVertexBuffers([self.spriteBuffer])
        self.device.setPrimitiveTopology(PRIMITIVE_TOPOLOGY_POINTLIST)
        self.device.setInputLayout(self.spriteInputLayout)
          
        #Update effect variables.
        viewInverse = d3d11.Matrix(viewMatrix)
        viewInverse.invert()
        self.spriteEffect.set("viewInverse", viewInverse)
        self.spriteEffect.set("viewProjection", viewMatrix * projMatrix)
        self.spriteEffect.set("defaultTexture", self.spriteTexture)
        self.spriteEffect.apply(0, 0)
          
        #First shadow points. Use an offset. Note that they are rotated
        #towards the camera too which is not that great. As an excercise
        #you could make them align using the surface normal. Or use real shadows.
        self.device.draw(POINT_COUNT, POINT_COUNT)
          
        #Then colored and textured points.
        self.device.draw(POINT_COUNT, 0)

          
if __name__ == "__main__":  
    frame = SpriteSample("3D Sprites", __doc__)
    frame.mainloop()
