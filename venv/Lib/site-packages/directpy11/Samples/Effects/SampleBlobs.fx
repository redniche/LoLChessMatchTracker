
#include "Shared.fx"

#define MERGE 0
#define META 1
#define WOBBLE 2
#define AVOID 3

cbuffer BlobInfo
{
    uint blobAction = 0;
    uint self = 0;
    float3 positions[BLOB_COUNT];
}

cbuffer Immutable
{
    static const float4 red = float4(1.0f, 0.0f, 0.0f, 1.0f);
    static const float4 green = float4(0.0f, 0.8f, 0.0f, 1.0f);
}

struct VS_INPUT {
    float4 position : POSITION;
    float3 normal : NORMAL;
    float2 tex : TEXTURE;
};

struct PS_INPUT {
    float4 position : SV_POSITION;   
    float4 color : COLOR;
    float2 tex : TEXTURE;
};

PS_INPUT RenderMeshVS(VS_INPUT input)
{
    PS_INPUT output;
    output.color = 0;
    output.position = 0;
    
    float4 position = mul(input.position, worldMatrix);
    
    for (uint i=0; i < BLOB_COUNT; ++i) { 
        if (i != self) {
            const float dist = distance(position.xyz, positions[i]);
            float3 dir = 0;
            if (blobAction == MERGE) {
                dir = normalize(positions[i] - position.xyz) / (dist) * 2;
            }
            else if (blobAction == META) {
                const float3 center = lerp(positions[i], positions[self], 0.4);
                const float3 move = center - positions[i];
                dir = normalize(positions[i] - position.xyz) / (dist) * 2;
                dir += move * 0.40;
            }
            else if (blobAction == WOBBLE) {
                position.x += sin(time + position.x) / 4;
                position.y += cos(time + position.y) / 6;
            }
            else if (blobAction == AVOID) {
                dir = -normalize(positions[i] - position.xyz);
            }
            position += clamp(float4(dir, 0.0f), -0.6f, 0.6f);    
            output.color += lerp(red, green, min(dist / 13.0, 1.0f));
        }
    }
    output.position = mul(position, viewProjection);
    
    output.tex = input.tex;
    return output;    
}

float4 RenderMeshPS(PS_INPUT input) : SV_Target
{ 
    return input.color;
}

RasterizerState RSNormal { 
    CullMode = FRONT; 
    MultisampleEnable = True;
    //FillMode = WireFrame;
    //ScissorEnable = True;
};

technique11 RenderMeshSingle {
    pass  {       
        SetVertexShader(CompileShader(vs_4_0, RenderMeshVS())); 
        SetGeometryShader(NULL);
        SetPixelShader(CompileShader(ps_4_0, RenderMeshPS()));    
    
        SetRasterizerState(RSNormal);
    }
}

