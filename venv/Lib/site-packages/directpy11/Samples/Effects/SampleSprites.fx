
#include "Shared.fx"

cbuffer spriteData
{
    float4x4 viewInverse;
    //float pointSize;
}

struct VS_GS_INPUT {
    float4 position : POSITION;
    float4 color : COLOR;
    float pointSize : PSIZE;
};

struct PS_INPUT {
    float4 position : SV_POSITION;   
    float4 color : COLOR;
    float2 tex : TEXTURE;
};

//Vertex shader.

VS_GS_INPUT VSSprites(VS_GS_INPUT input)
{
    return input;
}

//Geometry shader.

[maxvertexcount(4)]
void GSSprites(point VS_GS_INPUT input[1], inout TriangleStream<PS_INPUT> stream)
{
    //Use an array for texture coordinates, the loop will index this.
    const float2 texCoords[4] = {
        {0, 0}, {1, 0},
        {0, 1}, {1, 1},
    };

    for (int i=0; i < 4; ++i) {
        PS_INPUT output;
        //First compute vertex position in local coordinate space. Use
        //texture coordinates to offset the vertex in x and y direction.
        //z can be 0. Note that the is no need for a world transform, the
        //points are already in global space (you can of course add
        //a world transform if you want to move or rotate all points in some way).
        float3 worldPos = float3((float2(-0.5, -0.5) + texCoords[i]) * input[0].pointSize, 0);
        //Transform using inverse view matrix, this rotates the sprite towards the "camera".
        worldPos = mul(worldPos, (float3x3)viewInverse) + input[0].position.xyz;
        //Normal view and projection transform.
        output.position = mul(float4(worldPos, 1), viewProjection);

        output.color = input[0].color;
        output.tex = texCoords[i];
        
        stream.Append(output);
    }
}

//Pixel shader.

float4 PSSprites(PS_INPUT input) : SV_Target
{ 
    const float4 textureColor = defaultTexture.Sample(textureSampler, input.tex);
    
    //Alpha test. Not a very general one, the texture used in the
    //sample is not very good (very jagged alpha edges).
    if (textureColor.a < 0.9)
        discard;
    
    return textureColor * input.color;
}


RasterizerState RSNormal { 
    CullMode = None; 
};

technique11 RenderSprites {
    pass  {       
        SetVertexShader(CompileShader(vs_4_0, VSSprites())); 
        SetGeometryShader(CompileShader(gs_4_0, GSSprites()));
        SetPixelShader(CompileShader(ps_4_0, PSSprites()));    
    
        SetRasterizerState(RSNormal);
    }
}
