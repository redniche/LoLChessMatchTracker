
cbuffer effectData
{   
    //Size of the "screen" in pixels.
    float2 screenSize;
    float time;
    
    static const int2 offsets[5] = {
        {0, 0},
        {-1, 0},
        {0, -1},
        {1, 0},
        {0, 1},
    };
}

Texture2D postTexture;

SamplerState textureSampler {
    Filter = MIN_MAG_MIP_POINT; 
    AddressU = CLAMP; 
    AddressV = CLAMP;
};

struct VS_INPUT {
    float4 position : POSITION;
    float2 tex : TEXTURE;
};

struct PS_INPUT {
    float4 position : SV_POSITION;   
    float2 tex : TEXTURE;
};

PS_INPUT VSSprites(VS_INPUT input)
{
    PS_INPUT output;
    //Convert screen coordinates into device coordinates.
    output.position.x = (input.position.x) / (screenSize.x / 2.0) - 1;
    output.position.y = -((input.position.y) / (screenSize.y / 2.0)) + 1;
    output.position.z = 0.5;
    output.position.w = 1.0;
    output.tex = input.tex;
    return output;
}

//No effect.

float4 PSNormal(PS_INPUT input) : SV_Target
{ 
    return postTexture.Sample(textureSampler, input.tex);
}

//Invert color.

float4 PSInvert(PS_INPUT input) : SV_Target
{ 
    return 1.0f - postTexture.Sample(textureSampler, input.tex);
}

//Simple average blur.

float4 PSBlur(PS_INPUT input) : SV_Target
{ 
    float4 result = 0;
    [unroll] //Suppresses a warning about loop unrolling.
    for (int i=0; i < 5; ++i) {
        result += postTexture.Sample(textureSampler, input.tex, offsets[i] * 5);
    }
    return result / 5.0;
}

float4 PSDistort(PS_INPUT input) : SV_Target
{ 
    float4 result = 0;
    for (int i=0; i < 5; ++i) {
        float2 distored;
        distored.x = input.tex.x + (sin(time * i) * 0.05);
        distored.y = input.tex.y + (cos(time * 1.1 * i) * 0.05);
        result += postTexture.Sample(textureSampler, distored);
    }
    return result / 5.0;
}

DepthStencilState DisableDepthTestWrite {
    DepthEnable = FALSE;
    DepthWriteMask = ZERO;
    DepthFunc = ALWAYS;
};

RasterizerState RSNormal { 
    CullMode = None; 
};

technique11 RenderNormal {
    pass  {       
        SetVertexShader(CompileShader(vs_4_0, VSSprites())); 
        SetGeometryShader(NULL);
        SetPixelShader(CompileShader(ps_4_0, PSNormal()));    
    
        SetRasterizerState(RSNormal);
        SetDepthStencilState(DisableDepthTestWrite, 0);
    }
}

technique11 RenderInvert {
    pass  {       
        SetVertexShader(CompileShader(vs_4_0, VSSprites())); 
        SetGeometryShader(NULL);
        SetPixelShader(CompileShader(ps_4_0, PSInvert()));    
    
        SetRasterizerState(RSNormal);
        SetDepthStencilState(DisableDepthTestWrite, 0);
    }
}

technique11 RenderBlur {
    pass  {       
        SetVertexShader(CompileShader(vs_4_0, VSSprites())); 
        SetGeometryShader(NULL);
        SetPixelShader(CompileShader(ps_4_0, PSBlur()));    
    
        SetRasterizerState(RSNormal);
        SetDepthStencilState(DisableDepthTestWrite, 0);
    }
}

technique11 RenderDistort {
    pass  {       
        SetVertexShader(CompileShader(vs_4_0, VSSprites())); 
        SetGeometryShader(NULL);
        SetPixelShader(CompileShader(ps_4_0, PSDistort()));    
    
        SetRasterizerState(RSNormal);
        SetDepthStencilState(DisableDepthTestWrite, 0);
    }
}
