
# Copyright (C) 2010, Heikki Salo
# All rights reserved.
#
# Distributed under the BSD license:
# http://www.opensource.org/licenses/bsd-license.php

#True division.
from __future__ import division

import os
import time
import unicodedata
import math

import d3d11
import d3d11x
from d3d11x import Rect, STR
from d3d11c import *

unicode = STR

HIT_WINDOW = 0
HIT_CAPTION = 1
HIT_COLLAPSE = 2 
HIT_MAXIMIZE = 3
HIT_CLOSE = 4
HIT_RESIZEBORDER = 5
HIT_HELP = 6
HIT_CLIENT = 7

#Image file names.
GUI_IMAGE_X = "GUI-X"
GUI_IMAGE_MIN = "GUI-MIN"
GUI_IMAGE_MAX = "GUI-MAX"
GUI_IMAGE_DOWN = "GUI-DOWN"
GUI_IMAGE_UP = "GUI-UP"
GUI_IMAGE_RADIO = "GUI-RADIO"
GUI_SLIDER = "GUI-SLIDER"
GUI_IMAGE_CHECK = "GUI-CHECK"
_TOLOAD = (GUI_IMAGE_X, GUI_IMAGE_MIN, GUI_IMAGE_MAX, GUI_IMAGE_DOWN, 
    GUI_IMAGE_UP, GUI_IMAGE_RADIO, GUI_SLIDER, GUI_IMAGE_CHECK)
     
#Multiply color (RGBA) by a value. Note that alpha is not modified.
     
def _mulColor(color, v):
    return (min(color[0] * v, 1.0), min(color[1] * v, 1.0), min(color[2] * v, 1.0), color[3])
    
class Event(object):
    def __init__(self, msg, sender=None):
        self.sender = sender

        if msg:
            #Take value from an existing message.
            self.code = msg.code
            self.wparam = msg.wparam
            self.lparam = msg.lparam
            self.x = msg.x
            self.y = msg.y
            self.wheel = msg.wheel
            self.vk = msg.vk
            self.char = msg.char
            self.shift = msg.shift
            self.ctrl = msg.ctrl
            self.alt = msg.alt
        else:
            #"Zero" init values.
            self.code = WM_DP_INVALID 
            self.wparam = None
            self.lparam = None 
            self.x = None
            self.y = None
            self.wheel = None
            self.vk = None
            self.char = None
            self.shift = None
            self.ctrl = None
            self.alt = None
                
           
def _findWindowDefault(w, arg):
    if w.title == arg:
        return w
    return None
           
class Manager(object):

    #: A :class:`d3d11x.Sprite` used for drawing. Mostly used from :class:`d3d11gui.Window.onRender` callbacks.
    sprite = None

    def __init__(self, device, window, sprite=None): 
        """
        :param device: A :class:`d3d11.Device`.
        :param window: A :class:`d3d11.Window`.
        :param sprite: A :class:`d3d11x.Sprite` used for drawing. If None a default sprite will be created.
        
        Creates a new Manager. 
        """
        self.window = window
        self.device = device
        
        if sprite is None:
            sprite = d3d11x.Sprite(self.device, "Arial", 16)
        self.sprite = sprite 
        
        self.rootWindows = []
        self.focusWindow = None
        self.focusWindowRoot = None #The root window of 'self.focusWindow'
        self.client = None
        self.mousePos = (0, 0)
        self.frameTime = 0.0
        self.frameSpeed = 0.0
        self.tabIndex = 0
        self.mouseIdle = 0.0
        self.toolTipWindow = None
        self.toolTipDelay = 0.5
        
        #Dragging data.
        self.draggedWindow = None
        self.dragPos = None
        self.dragNotified = False
        
        #Resizing data.
        self.resizedWindow = None
        self.resizeNotified = False
        
        #Hover data
        self.hoverWindow = None
        
        self.update()
        self._updateSprite()
        self.textHeight = self.sprite.textHeight
        
    def _updateSprite(self):
        texDir = d3d11x.getResourceDir("Textures")
        for image in _TOLOAD: 
            path = os.path.join(texDir, image + ".png")
            self.sprite.loadTexture(path, image)

    def _recurseGetWindow(self, x, y, w):
        for child in w.children:
            if child.hitTest(x, y, HIT_WINDOW):
                return self._recurseGetWindow(x, y, child)
        return w
        
    def getHoverWindow(self):
        """Returns the window which is currently under the mouse cursor or None."""
        return self.hoverWindow
        
    def getFocusWindow(self):   
        """Returns the focus window or None."""
        return self.focusWindow
        
    def getWindowAt(self, x, y):
        """Returns the window at given coordinates or None."""
        for w in self.rootWindows:
            if w.hitTest(x, y, HIT_WINDOW):
                if w.hitTest(x, y, HIT_CLIENT):
                    #It can hit some child window.
                    #if w.hitTest(x, y, HIT_RESIZEBORDER):
                        #Border resize area wins always.
                    #    return w
                    
                    #Look for children.
                    return self._recurseGetWindow(x, y, w)
                else:
                    #Can't hit anything else.
                    return w
        return None
        
    def _recurseAddWindow(self, w, windows):
        windows.append(w)
        for child in w.children:
            self._recurseAddWindow(child, windows)
        
    def getAllWindows(self):
        """Returns all windows that are owned by this manager."""
        windows = []
        for root in self.rootWindows:
            #Recurisvely add all child windows (and root).
            self._recurseAddWindow(root, windows)
        return windows  
        
    def _findWindowRecurse(self, w, name, func):
        if func(w, name):
            return w
        for child in w.children:
            return self._findWindowRecurse(child, name, func)
        return None
        
    def findWindow(self, arg, callback=None):
        """
        :param arg: Argument passed to ``callback``.
        :param callback: Function used to determine if a window should be returned.
            If None a default is used and windows are searched by their title.
        :returns: The found window or None.
        
        Searches for a window. You can pass a query fuction to customize what
        window you want to be returned. The callback function should accept two parameters
        ``window`` and ``arg``. The first is the window being tested and the second
        is the same as passed to findWindow(). The callback should return True if
        it found a satisfactory window. ::
        
            #Find a window with a "Tools"-title. 
            window = manager.findWindow("Tools")
        """
        if callback is None:
            callback = _findWindowDefault
        
        for w in self.rootWindows:
            hit = self._findWindowRecurse(w, arg, callback)
            if hit:
                return hit
        return None
        
    def getRootWindows(self):
        """Returns all root windows (ie. windows that don't have a parent)."""
        return self.rootWindows[:]
        
    def getScreenRect(self):
        return Rect(0, 0, self.client[0], self.client[1])
        
    def update(self):
        screen = self.device.getScreenDesc()
        self.client = (screen.width, screen.height)
        for w in self.rootWindows:
            w.update()
        
    def close(self):
        """Closes the manager and every window it owns. Don't use the manager after calling this."""
        if self.rootWindows is None:
            return #Already closed.
    
        for root in self.rootWindows[:]:
            root.close()
        self.sprite = None
        self.rootWindows = None
        
    def _closeToolTip(self):
        if self.toolTipWindow:
            self.toolTipWindow.close()
            self.toolTipWindow = None
        
    def _neverHit(self, *args):
        return False
        
    def _showTooltip(self):
        if self.hoverWindow is None:
            return 
        if self.toolTipWindow is not None:
            return
        if not self.hoverWindow.toolTip:
            return
            
        event = Event(None, self.hoverWindow)
        event.x = self.mousePos[0]
        event.y = self.mousePos[1]  
        tipText = self.hoverWindow.onGetToolTip(event)
        
        #Compute a rough size for the tooltip.
        maxWidth = 250
        x = 0
        w = 0
        h = self.textHeight
        for word in tipText.split():
            wordWidth = self.sprite.getTextSize(word)[0]
            x += wordWidth + 5
            w = max(w, x)
            if x > maxWidth:
                #Word wrap.
                x = wordWidth
                h += self.textHeight

        x, y = self.mousePos
        y += 20
        w = w + 10
        h = h + 10
        
        #Adjust position if needed.
        screen = self.getScreenRect()
        if x + w > screen.width:
            x = screen.width - w - 10
        if y + h > screen.height:
            y = self.mousePos[1] - h - 5
        
        #Create the window.
        tip = Window(self, Rect(x, y, w, h))
        tip.color = _mulColor(tip.color, 1.2)
        tip.captionHeight = 0
        tip.resizable = False
        tip.text = tipText
        tip.hitTest = self._neverHit
        
        self.toolTipWindow = tip
        
    def _dragStart(self, event, x, y, w):
        #User starts to drag a window.
        self._dragEnd(event)
        self.dragPos = (x - w.rect.x, y - w.rect.y)
        self.draggedWindow = w  
        self.dragNotified = False
        
    def _dragOn(self, event, x, y):
        if not self.dragNotified:
            #Only notify when the mouse actually moves.
            self.draggedWindow.onDragBegin(event)
            self.dragNotified = True
            
        #Move the dragged window.
        rect = self.draggedWindow.rect
        newRect = Rect(x - self.dragPos[0], y - self.dragPos[1], rect.width, rect.height)
        self.draggedWindow.setRect(newRect)
        self.draggedWindow.onDrag(event)
        
    def _dragEnd(self, event):
        #User stops dragging a window.
        if self.draggedWindow and self.dragNotified:
            self.draggedWindow.onDragEnd(event)
        self.draggedWindow = None
        self.dragPos = None
        self.dragNotified = False
        
    def _resizeStart(self, event, w):
        #User start to resize a window.
        self._resizeEnd(event)
        self.resizedWindow = w
        self.resizeNotified = False
        
    def _resizeOn(self, event, x, y):
        #User is resizing a window.
        if not self.resizeNotified:
            self.resizedWindow.onResizeBegin(event)
            self.resizeNotified = True
    
        sizeAdd = 3
        rect = self.resizedWindow.rect
        newRect = Rect(rect.x, rect.y, x - rect.x + sizeAdd, y - rect.y + sizeAdd)
        self.resizedWindow.setRect(newRect)
        
    def _resizeEnd(self, event):
        #User stops resizing a window.
        if self.resizedWindow and self.resizeNotified:
            self.resizedWindow.onResizeEnd(event)
        self.resizedWindow = None
        self.resizeNotified = False
        
    def _hoverStart(self, event, w):
        #Mouse has just entered a window's area.

        if w is not self.hoverWindow:
            self._closeToolTip()
        
            if self.hoverWindow:
                self.hoverWindow.onMouseLeave(event)
            if w:
                w.onMouseEnter(event)
        
        self.hoverWindow = w
    
        if self.hoverWindow:
            cursor = self.hoverWindow.onGetCursor(event)
            if cursor:
                self.window.setCursor(cursor)
        
            self.hoverWindow.onMouseMove(event)
   
    def _giveFocus(self, event, w):
        #Give focus to a window (or None).
        if self.focusWindow is w:
            return
    
        if self.focusWindow:
            oldFocus = self.focusWindow
            self.focusWindow = w #Avoid infinite recursion if window hides() etc.
            oldFocus.onLoseFocus(event)
            
            if self.focusWindow is not w:
                #Callback gave focus to some other window.
                return

        if not w:
            self.focusWindow = None
            self.focusWindowRoot = None
            return
            
        #Bring the "main window" to front.
        root = w.getRoot()
        self._removeRoot(root)
        self._addRoot(root)
        
        self.focusWindowRoot = root
        self.focusWindow = w
        self.focusWindow.onGetFocus(event)

    def _handleMouseMessage(self, msg, x, y, w):
        self.mousePos = (x, y)
        code = msg.code
    
        if w is not None and w.disabled:
            #Don't send messages to disabled windows.
            w = None
    
        #Replace msg by an Event
        msg = Event(msg, w)
   
        self._hoverStart(msg, w)

        #if code != WM_MOUSEMOVE:
        self._closeToolTip()
        
        if code == WM_MOUSEMOVE:
            if self.draggedWindow: #User is dragging a window.
                self._dragOn(msg, x, y)
            if self.resizedWindow: #User is resizing a window.
                self._resizeOn(msg, x, y)
        elif code == WM_LBUTTONDOWN:
            if w:
                #Note that onMouseButton() is received *before* giveFocus() -> onGetFocus()
                w.onMouseButton(msg) 
                if w.valid:
                    w.giveFocus()
                    if w.valid: 
                        if w.hitTest(x, y, HIT_RESIZEBORDER) and w.resizable:
                            self._resizeStart(msg, w)
                        elif w.hitTest(x, y, HIT_CAPTION) and not w.maximized and not w.anchor and w.movable:
                            #Caption hit, possibly start dragging.
                            if not (w.hitTest(x, y, HIT_COLLAPSE) or w.hitTest(x, y, HIT_MAXIMIZE) or w.hitTest(x, y, HIT_CLOSE)):
                                #Did not hit any buttons, start dragging.
                                self._dragStart(msg, x, y, w)
                else:
                    #Callbacked window was closed.
                    self._giveFocus(None, None)          
            else:
                self._giveFocus(None, None)
  
        elif code == WM_LBUTTONUP:
            oldDragged = self.draggedWindow 
            self._resizeEnd(msg)
            self._dragEnd(msg)
            if w:
                w.onMouseButton(msg) #XXX don't call if drag-drop is done.
                if w.valid:
                    if oldDragged:
                        #Test for drag and drop.
                        oldDragged.hidden = True
                        target = self.getWindowAt(x, y)
                        oldDragged.hidden = False
                        if target and not target.disabled and target.hitTest(x, y, HIT_CLIENT):
                            target.onDrop(msg, oldDragged)

                    if w.valid:
                        if w.hitTest(x, y, HIT_CLOSE):
                            w.close()
                        elif w.hitTest(x, y, HIT_MAXIMIZE): 
                            w.maximize(not w.maximized)
                        elif w.hitTest(x, y, HIT_COLLAPSE): 
                            w.collapse(not w.collapsed) 

        elif code in (WM_LBUTTONDBLCLK, WM_RBUTTONDOWN, WM_RBUTTONUP, WM_RBUTTONDBLCLK, WM_MBUTTONDOWN, 
            WM_MBUTTONUP, WM_MBUTTONDBLCLK, WM_XBUTTONDOWN, WM_XBUTTONUP, WM_XBUTTONDBLCLK):
                if w:
                    w.onMouseButton(msg)
        elif code == WM_MOUSEWHEEL:
            if self.focusWindow:
                msg.sender = self.focusWindow #Redirect.
                self.focusWindow.onMouseWheel(msg)
                  
    def onMessage(self, msg):
        """An event callback which returns True if the manager handled the message."""
        if d3d11x.isMouseMessage(msg):
            self.mouseIdle = 0.0
        
            self.window.setCursor(IDC_ARROW)
            x, y = msg.x, msg.y
            w = self.getWindowAt(x, y)
            self._handleMouseMessage(msg, x, y, w)
            if w:
                return True #Handled it.      
                
        elif d3d11x.isKeyMessage(msg):
            if self.focusWindow:
                event = Event(msg, self.focusWindow)
                if msg.code == WM_CHAR:
                    self.focusWindow.onChar(event)
                else:
                    self.focusWindow.onKey(event)
                return True #Handled.
        elif msg.code == WM_SIZE:
            self.update() 
        elif msg.code == WM_ACTIVATE:
            #Visual tweak.
            self.hoverWindow = None
        return False #Not handled.
   
    def _addRoot(self, w):
        assert(w not in self.rootWindows)
        assert(w.parent is None)
        self.rootWindows.insert(0, w)
        
    def _removeRoot(self, w):
        i = self.rootWindows.index(w)
        self.rootWindows.pop(i)
        
    def _disableInteraction(self, w):
        #Called when a window is closed, disabled, hidden etc.
        if w is self.draggedWindow:
            self._dragEnd()
        if w is self.resizedWindow:
            self._resizeEnd()
        if w is self.hoverWindow:
            self._hoverStart(None, None)
        if w is self.focusWindow:
            self._giveFocus(None, None)
          
    def render(self, frameTime):
        """Renders all windows."""
        self.frameTime = frameTime
        #For adjusting movement speed.
        self.frameSpeed = frameTime / (1.0 / 60.0) 
    
        self.mouseIdle += self.frameTime
        if self.mouseIdle > self.toolTipDelay:
            self._showTooltip()
    
        screen = self.device.getScreenDesc()
        self.client = (screen.width, screen.height)
    
        self.sprite.begin()
        for root in reversed(self.rootWindows):
            self.device.setScissorRects([(0, 0, self.client[0], self.client[1])])
            root._onRenderInternal(root.dragged, root.disabled)
            self.sprite.flush()
        self.sprite.end()
        

class Window(object):
    #: Alpha value of the window (from 0.0 to 1.0). Class attribute used for initialization. (R/W)
    alpha = 0.9
    #: Caption color in RGBA format. (R/W)
    captionColor = (0.45, 0.45, 0.65, alpha)
    #: Border color in RGBA format. (R/W)
    borderColor = (0.35, 0.35, 0.35, alpha)
    #: Background color in RGBA format. (R/W)
    color = (0.7, 0.7, 0.9, alpha) 
    #: Title text color in RGBA format. (R/W)
    titleColor = (0, 0, 0, alpha)
    #: Text color in RGBA format. (R/W)
    textColor = (0, 0, 0, alpha)
    #: Width of the window border. (R/W)
    borderSize = 1
    #: Height of the caption. If 0 no caption is used. (R/W)
    captionHeight = 35
    #: Size of the caption buttons (close etc.) as a tuple (width, height). (R/W)
    buttonSize = (25, 25)
    #: Minimum size of the window as a tuple (width, height). (R/W)
    minSize = (20, 10)
    #: Maximum size of the window as a tuple (width, height). (R/W)
    maxSize = (5000, 5000)
    #: Text padding in each direction (left, top, right, bottom). (R/W)
    textPad = (5, 5, 5, 5)
    #: When True a scissor rectangle is used when rendering children. Only used on root windows. (R/W)
    useClipRect = True
    
    #: Window's :class:`Manager`. (R)
    manager = None
    #: Window's parent window. (R)
    parent = None
    #: All immediate children. (R)
    children = None
    #: True if the window is currently hidden. (R)
    hidden = None
    #: True if the window is currently disabled. (R)
    disabled = None
    #: If True the window can be resized by the user. (R/W)
    resizable = None
    #: If True the window can be moved by the user. (R/W)
    movable = None
    #: True if the window is currently collapsed. (R)
    collapsed = None
    #: True if the window is currently maximized. (R)
    maximized = None
    #: Window anchor or None. (R)
    anchor = None
    #: Caption title text. (R/W)
    title = None
    #: Content text. (R/W)
    text = None
    #: Tooltip text. (R/W)
    toolTip = None
    
    def __init__(self, parent, rect):
        """
        :param parent: A :class:`~d3d11gui.Manager` or another Window.
        :param rect: Window rectangle. If ``parent`` is another window
            x and y will be interpreted as local coordinates relative
            to the parent window.
            
        Creates a new Window.
        """
        self.manager = None
        self.rect = Rect(0, 0, 1, 1)
        self.parent = None
        self.children = []
        self.hidden = False
        self.disabled = False
        self.resizable = True
        self.movable = True
        self.collapsed = False 
        self.maximized = False
        self.anchor = None
        
        if isinstance(parent, Manager):
            #New root window.
            self.manager = parent
            self.manager._addRoot(self)
        else:
            #Parent window given.
            parent.addChild(self)
            self.manager = self.parent.manager
            #Move from local to global.
            client = parent.getClientRect()
            rect = Rect(client.x + rect.x, client.y + rect.y, rect.width, rect.height)
            
        self.title = "Untitled"
        self.text = ""
        self.toolTip = ""
        
        #Internal
        self._modalstate = None
            
        self.setRect(rect)
        
    def _adjustColor(self, color, event, value=1):
        #This is used to adjust window colors based on current state.
        
        if color is None:
            return None
    
        if value != 1:
            #Explicit value.
            #color = (color[0] * value, color[1] * value, color[2] * value, color[3])
            color = _mulColor(color, value)
    
        if event.disabled:
            #Darken.
            #color = (0.2, 0.2, 0.2, color[3])
            color = _mulColor(color, 0.65)

        if event.dragged:
            #Make more transparent.
            color = color[:3] + (color[3] * 0.75, )  

        return color
        
    @property
    def dragged(self):
        """True if the window is currently dragged by the user. (R)"""
        return self is self.manager.draggedWindow and self.manager.dragNotified
        
    @property
    def resizing(self):
        """True if the window is currently resized by the user. (R)"""
        return self is self.manager.resizedWindow and self.manager.resizeNotified
        
    @property
    def valid(self):
        """True if the window has not been closed. (R)"""
        return self.manager is not None
        
    @property
    def modal(self):
        """True if the window is currently in modal state. (R)"""
        return self._modalstate is not None
        
    def hide(self, yes=True):
        """Hides or shows the Window and all it's child windows."""
        for child in self.children:
            child.hide(yes)
        self.hidden = yes
        if yes:
            self.manager._disableInteraction(self)
        
    def disable(self, yes=True):
        """
        Disabled or enables the Window and all it's child windows. Disabled
        windows don't receive any window messages.
        """
        for child in self.children:
            child.disable(yes)
        self.disabled = yes
        if yes:
            self.manager._disableInteraction(self)
        
    def resize(self, width, height):
        """Resizes the window without moving it."""
        self.setRect(Rect(self.rect.x, self.rect.y, width, height))
        
    def setAnchor(self, anchor):
        """
        :param anchor: A 4-tuple (note that this is not a Rect) or None. If None no anchor will be used.
        
        Sets anchor information. An anchor is a tuple of four elements which specify how
        the window should behave when it's parent area is moved or resized. Element order
        is ``left, top, right, bottom``. For example anchor ``(None, None, 10, 10)``
        tells that right and bottom sides of the window are "anchored" and should 
        always be 10 pixels from the parent border. Because left and top borders are
        not specified the size of the window will not change when the parent is resized.
        Another example ``(10, 10, 10, 10)`` tells that the window should always have
        space of 10 pixels in each direction relative to the parent. This can also cause
        the window to be resized when this constraint must be satisfied. 
        """
        self.anchor = anchor
        if anchor:
            self.update()
        
    def getRect(self):
        """Returns the window's rectangle as a new Rect. Always in global coordinates."""
        return self.rect.copy()
        
    def setRect(self, newrect):
        """
        Sets the window rectangle in global coordinates. All constraints 
        like ``minSize`` and ``anchor`` are applied to the new rectangle so
        the final size might not be what you specified.
        """
        self._oldRect = self.rect
    
        difx = newrect.x - self.rect.x
        dify = newrect.y - self.rect.y 
        
        #Clamp width and height.
        w = min(max(newrect.width, self.minSize[0]), self.maxSize[0])
        h = min(max(newrect.height, self.minSize[1]), self.maxSize[1])
        self.rect = Rect(newrect.x, newrect.y, w, h)
        
        if self.anchor is not None:
            self.rect = self._spacerRect()
        
        for child in self.children:
            #Move all children.
            r = child.rect
            r = Rect(r.x + difx, r.y + dify, r.width, r.height)
            child.setRect(r)
            
        #if self._oldRect.width != self.rect.width or self._oldRect.height != self.rect.height:
        self.onResize(Event(None, self)) #Callback
          
    def getClientRect(self):
        """
        Returns the client area of the window. This is the area which excludes borders,
        caption etc. Always in global coordinates.
        """
        r = self.rect
        pad = self.borderSize
        return Rect(r.x + pad, r.y + pad + self.captionHeight, 
            r.width - pad * 2, r.height - self.captionHeight - pad * 2)
        
    def getTextRect(self):
        """
        This is similar to :meth:`getClientRect` except that ``.textPad`` is also used  
        when computing the area. Always in global coordinates.
        """
        r = self.rect
        borderpad = self.borderSize
        textpad = self.textPad
        return Rect(r.x + borderpad + textpad[0],
            r.y + borderpad + self.captionHeight + textpad[1],
            r.width - borderpad * 2 - textpad[0] - textpad[2],
            r.height - self.captionHeight - borderpad * 2 - textpad[1] - textpad[3])
             
    def giveFocus(self):
        """Gives focus to the window."""
        self.manager._giveFocus(Event(None, self), self)
            
    def update(self):
        """
        Updates the window and all it's child windows. Call this
        if you have changed the ``.minSize`` etc.
        """
        if self.maximized:
            w, h = self.manager.client
            self.setRect(Rect(0, 0, w, h))
            
        if self.anchor:
            r = self._spacerRect()
            self.setRect(r)
            
        for child in self.children:
            child.update()
             
    def addChild(self, child): 
        """
            Adds a child window to this window. 
        """
        assert(child not in self.children)
        assert(child.parent is None)
        if child in self.manager.rootWindows:
            self.manager._removeRoot(child)
        self.children.append(child)
        child.parent = self
        
    def removeChild(self, child):
        """
            Removes the child from window's children. After this
            the child is a root window.
        """
        assert(child.parent is self)
        i = self.children.index(child)
        self.children.pop(i)
        child.parent = None
        self.manager._addRoot(child) 
        
    def getAllChildren(self):
        """
        Returns every child and descendant of the window. You can 
        use the ``.children`` attribute to access immediate children.
        """
        children = self.children[:]
        for child in self.children:
            children.extend(child.getAllChildren())
        return children
        
    def getRoot(self):
        """
        Returns the root window of a window. This will 
        return itself if called on a root window.
        """
        root = self
        while root.parent is not None:
            root = root.parent
        return root
        
    def getParents(self):
        """Returns window's parents as a list."""
        parents = []
        next = self.parent
        while next is not None:
            parents.append(next)
            next = next.parent
        return parents   
        
    def close(self):
        """
        Closes the window and all it's child windows. 
        Don't use the window after calling this.
        """
        if not self.valid:
            #Ok to close window multiple times.
            return
    
        #Callback first.
        self.onClose(Event(None, self)) 
    
        for w in self.children[:]:
            w.close()
            
        assert(len(self.children) == 0)
            
        if self.parent:
            self.parent.removeChild(self)

        self.manager._removeRoot(self)
            
        if self.modal:
            self.makeModal(False)
          
        #Remove manager for _disableInteraction(). 
        manager = self.manager
        self.manager = None
        self.rect = None
          
        manager._disableInteraction(self)

    def center(self, xaxis=True, yaxis=True):
        """
        Centers the window inside it's parent. If it has no parent it is centered on the srceen.
        """
        area = (0, 0) + self.manager.client
        if self.parent:
            area = self.parent.getClientRect()
            
        x = self.rect.x
        if xaxis:
            x = area[0] + area[2] // 2 - self.rect.width // 2
        
        y = self.rect.y
        if yaxis:
            y = area[1] + area[3] // 2 - self.rect.height // 2
      
        self.setRect(Rect(x, y, self.rect.width, self.rect.height))
        
    def maximize(self, yes=True):
        """Maximizes or restores the window."""
        assert(self.parent is None) 
        #assert(self.anchor is None)
        self.collapse(False)
        self.maximized = yes
        if yes:
            self._preMaxRect = self.rect #Used only inside this method.
            self.update()
        else:
            if hasattr(self, "_preMaxRect"):
                self.setRect(self._preMaxRect)
        
    def collapse(self, yes=True):
        """Collapses or uncollapses the window."""
        self.collapsed = yes
        
    def makeModal(self, yes=True):
        """
        Makes the windows modal. All other windows will be disabled. When the
        window is closed or ``makeModal(False)`` is called other windows
        will be restored to the state they were when this window was made modal.
        """
        #This method sets the .disabled
        #attribute directly. Things should
        #not break, unless some custom 
        #controls do something funny.
        assert (self.parent is None)
        if yes:
            assert(self._modalstate is None)
            self.giveFocus()

            keepTheseEnabled = self.getAllChildren()
            keepTheseEnabled.append(self)
            
            self._modalstate = {}
            for w in self.manager.getAllWindows():
                if w not in keepTheseEnabled:
                    self._modalstate[w] = w.disabled
                    w.disabled = True
        else:
            for w, state in self._modalstate.items():
                w.disabled = state
            self._modalstate = None
        
    def hitTest(self, x, y, area):
        """
        :param area: The area to be tested for. See :ref:`HitTesting`.
        
        Returns True if the given coordinates hit the given window area. You can
        override this method if you want to make custom widgets. If the window
        is hidden this should always return False.
        """
        if self.hidden:
            return False
            
        r = self.rect
        if area == HIT_WINDOW:
            if self.collapsed:
                r = Rect(r.x, r.y, r.width, self.captionHeight)
            return r.pointInside(x, y)
        elif area == HIT_CAPTION:
            if self.captionHeight > 0:
                return Rect(r.x, r.y, r.width, self.captionHeight).pointInside(x, y)
        elif area == HIT_CLOSE:
            if self.captionHeight > 0:  
                return self._getButtonRect(0).pointInside(x, y)
        elif area == HIT_MAXIMIZE:
            if self.captionHeight > 0 and not self.anchor and self.resizable: 
                return self._getButtonRect(1).pointInside(x, y)
        elif area == HIT_COLLAPSE:
            if self.captionHeight > 0: 
                return self._getButtonRect(2).pointInside(x, y)
        elif area == HIT_RESIZEBORDER:
            if self.captionHeight > 0 and not self.collapsed and self.resizable:  
                caph = self.captionHeight
                w2 = r.width // 2
                h2 = r.height // 2
                bsize = self.borderSize + 8 #Easier to resize.
                bottom = Rect(r.x + w2, r.y + r.height - bsize, r.width - w2, bsize)
                right = Rect(r.x + r.width - bsize, r.y + caph + h2, bsize, r.height - caph - h2)  
                return bottom.pointInside(x, y) or right.pointInside(x, y) 
        elif area == HIT_CLIENT:
            if not self.collapsed:
                return self.getClientRect().pointInside(x, y)
        return False
        
    def _spacerRect(self):
        #Returns the adjusted window rect.
        if self.anchor is None:
            return self.rect
        
        if self.parent is not None:
            pr = self.parent.getClientRect()
        else:
            pr = (0, 0, self.manager.client[0], self.manager.client[1])
            
        s = self.anchor
        x = self.rect[0]
        y = self.rect[1]
        w = self.rect[2]
        h = self.rect[3]

        #x position
        if s[0] is not None:
            x = pr[0] + s[0]

        #Width
        if s[2] is not None:
            w = (pr[0] + pr[2] - s[2]) - x
            if s[0] is None:
                w = self.rect[2]
                x = pr[0] + pr[2] - s[2] - w
            
        #y position
        if s[1] is not None:
            y = pr[1] + s[1]

        #Height
        if s[3] is not None:
            h = (pr[1] + pr[3] - s[3]) - y
            if s[1] is None:
                h = self.rect[3]
                y = pr[1] + pr[3] - s[3] - h
            
        return Rect(x, y, w, h)
        
    def _getButtonRect(self, i):
        #Right to left
        x = self.rect.x + self.rect.width - self.borderSize - self.buttonSize[0] - 10
        y = self.rect.y + self.borderSize + self.captionHeight // 2 - self.buttonSize[1] // 2
        return Rect(x - (self.buttonSize[0] + 5) * i - 1, y - 1, self.buttonSize[0] + 2, self.buttonSize[1] + 2)
        
    def _onRenderInternal(self, dragged, disabled):
        if self.hidden:
            return
            
        if self.parent:
            if self.rect.width <= 0 or self.rect.height <= 0:
                #Can't render, nothig is visible.
                return
            
        event = Event(None, self)
        event.dragged = dragged
        event.disabled = disabled
        self.onRender(event)
        
        if self.collapsed:
            return
        
        if self.parent is None:
            client = self.getClientRect()
            if client.width <= 0 or client.height <= 0:
                #No children are visible.
                return
        
            self.manager.sprite.flush()
            if self.useClipRect:
                self.manager.device.setScissorRects([client])
            
        #Recursively render children.
        for child in self.children:
            if not child.hidden:
                child._onRenderInternal(dragged, disabled)
        
        
    def onRender(self, event): 
        """Called when the window should draw itself."""
        r = self.rect
        sprite = self.manager.sprite
        border = self.borderSize 
        border2 = border * 2
        color = self._adjustColor(self.color, event)
        separator = border #Line between client and caption.
        windowHeight = r.height
        if self.collapsed:
            windowHeight = self.captionHeight + border * 2 - separator
            #separator = 0
        
        capAdjust = 1
        #if self.parent: could be tested too.
        if self is self.manager.getFocusWindow() or self is self.manager.focusWindowRoot:
            capAdjust = 1.2
        captionColor = self._adjustColor(self.captionColor, event, capAdjust)
        borderColor = self._adjustColor(self.borderColor, event, capAdjust)
        
        #Window border.
        sprite.drawRect(r.x, r.y, r.width, windowHeight, None, None, borderColor, border)

        if self.captionHeight > 0:
            #Caption background.
            sprite.drawRect(r.x + border, r.y + border, r.width - border2, 
                self.captionHeight - separator, captionColor, gradient=1.5)

            if not self.collapsed:
                #Line between caption and client area.
                sprite.drawRect(r.x + border, r.y + border + self.captionHeight - border, 
                    r.width - border2, separator, borderColor)
                
            #Caption text.
            y = r.y + border + self.captionHeight // 2 - sprite.textHeight // 2
            sprite.drawText(self.title, r.x + border + 10, y, r.width - 20, self.captionHeight,
                self.titleColor, d3d11x.TEXT_SINGLELINE)

            #Caption buttons.
            buttons = [GUI_IMAGE_X, GUI_IMAGE_MAX, GUI_IMAGE_UP]
            if self.collapsed:
                buttons[2] = GUI_IMAGE_DOWN
            if self.maximized:
                buttons[1] = GUI_IMAGE_MIN
                
            buttonGradient = 0.7
            imageColor = self._adjustColor((1, 1, 1, self.alpha), event)
            for i, name in enumerate(buttons):
                if i == 1:
                    if self.anchor or not self.resizable:
                        continue

                buttoncolor = self._adjustColor(self.captionColor, event, 0.65) 
                br = self._getButtonRect(i)
                if self is self.manager.getHoverWindow() and br.pointInside(*self.manager.mousePos): #Use hitTest() instead...
                    buttoncolor = (1, 1, 1, 1)
                sprite.drawRect(br.x, br.y, br.width, br.height, imageColor, name, buttoncolor, 1, buttonGradient)
                    
        if self.collapsed:
            return
        
        #Main background.
        sprite.drawRect(r.x + border, r.y + self.captionHeight + border, r.width - border2, 
            r.height - self.captionHeight - border2, color, gradient=0.7)
        
        #Any client text.
        if self.text:
            client = self.getTextRect()
            clienth = client.height - self.manager.sprite.textHeight + self.textPad[1]
            sprite.drawText(self.text, client.x, client.y, client.width, clienth, self.textColor)
         
    def onMouseEnter(self, event):
        """Called when the mouse enters into the window area."""
        return
        
    def onMouseMove(self, event):
        """Called when the mouse is moving inside the window."""
        return
        
    def onMouseLeave(self, event):
        """Called when the mouse has left the window."""
        return
        
    def onMouseButton(self, event):
        """Called when a mouse button has been pressed or released."""
        return
        
    def onMouseWheel(self, event):
        """Called when the user rotates the mouse wheel. Only the focus
        window will receive this event."""
        return
        
        
    def onDrag(self, event):
        """Called when the user is dragging the window."""
        return
        
    def onDragBegin(self, event):
        """Called when the user starts to drag the window."""
        return
        
    def onDragEnd(self, event):
        """Called when the user stops dragging the window."""
        return
        
        
    def onResizeBegin(self, event):
        """Called when the user starts to resize the window."""
        return
        
    def onResize(self, event):
        """Called when the window has been resized (by user, :meth:`setRect` etc.). This is also
        called when the window has been moved."""
        return
        
    def onResizeEnd(self, event):
        """Called when the user has stopped resizing the window."""
        return
        
        
    def onDrop(self, event, other):
        """Called when the window has been drag-and-dropped into another window.
        The "target" window will receive this event.
        """
        return
        
    def onClose(self, event):
        """Called when the window is about to be closed."""
        pass
        
    def onLoseFocus(self, event):
        """Called when the window has lost focus."""
        return
        
    def onGetFocus(self, event):
        """
        Called when the window has gained focus. By default this gives focus to the root
        window. If you want to keep focus on your window, override this method (just
        an empty stub will do).
        """
        self.getRoot().giveFocus()
        
    def onGetCursor(self, event):
        """
        Called when a mouse is moving over the window. If this returns something
        that evaluates to True it will be passed to :meth:`d3d11.Window.setCursor`.
        """
        if self.resizable and self.hitTest(event.x, event.y, HIT_RESIZEBORDER):
            return IDC_SIZENWSE
        
    def onGetToolTip(self, event):
        """Called when a tooltip string should be displayed. 
        By default this returns ``self.toolTip``."""
        return self.toolTip
        
    def onKey(self, event):
        """Called when a user presses, holds down or releases a key. 
        Only the focus window will receive this event."""
        return
        
    def onChar(self, event):
        """
        Called when a user types a character into a window. Note that control characters (newline, backspace etc.) 
        are included too. This is a convenience callback, :meth:`~d3d11gui.Window.onKey` receives these
        messages as WM_KEYDOWN / WM_KEYUP. Only the focus window will receive this event.
        """
        return
        
        
class Label(Window):
    def __init__(self, parent, rect, text="", title=""):
        """Creates a new Label."""
        Window.__init__(self, parent, rect)
        self.captionHeight = 0
        self.resizable = False
        self.color = (0, 0, 0, 0) #None
        self.text = text
        self.title = title
        self.borderColor = (0, 0, 0, self.alpha)
            
    def onRender(self, event):
        if self.title:
            sprite = self.manager.sprite
            r = self.rect
            border = self.borderSize
            th = self.manager.textHeight
            yoffset = th // 2
            liney = r.y + yoffset
            
            borderColor = self._adjustColor(self.borderColor, event)
            titleColor = self._adjustColor(self.titleColor, event)
            
            #Title.
            endx, endy = sprite.drawText(self.title, r.x + 20, r.y, r.width - 20, 
                r.height, titleColor, d3d11x.TEXT_SINGLELINE)
        
            #Two top lines.
            sprite.drawRect(r.x, liney, 15, border, borderColor)
            lx = endx + 5
            lw = (r.x + r.width) - endx - 5 
            if lw > 0:
                sprite.drawRect(lx, liney, lw, border, borderColor)
            #Left.
            sprite.drawRect(r.x, r.y + yoffset + border, border, r.height - yoffset - border, borderColor)
            #Right.
            sprite.drawRect(r.x + r.width - border, r.y + yoffset + border, border, r.height - yoffset - border, borderColor)
            #Bottom.
            sprite.drawRect(r.x, r.y + r.height, r.width, border, borderColor)
             
            #Text.
            client = self.getTextRect()
            sprite.drawText(self.text, client.x, client.y + th, client.width, client.height - th, self.textColor)
        else:
            Window.onRender(self, event)
        

class Button(Window):
    textFlags = d3d11x.TEXT_XCENTER | d3d11x.TEXT_YCENTER | d3d11x.TEXT_SINGLELINE

    def __init__(self, parent, rect, text=""):
        """Creates a new Button."""
        Window.__init__(self, parent, rect)
        self.resizable = False
        self.captionHeight = 0
        self.text = text
        self._clickReady = False
        
    def onMouseButton(self, event):
        if event.code == WM_LBUTTONDOWN:
            self._clickReady = True
        elif event.code == WM_LBUTTONUP:
            if self._clickReady:
                #Callback
                self.onClick(event)
            self._clickReady = False
        
    def onMouseLeave(self, event):
        self._clickReady = False
        
    def onClick(self, event):
        """Called when the user has clicked the button."""
        return
        
    def onRender(self, event):
        text = self.text
        color = self.color
        rect = self.rect
        
        if self is self.manager.getHoverWindow():
            self.color = _mulColor(self.color, 1.2)
        if self._clickReady:
            self.rect = Rect(self.rect.x + 1, self.rect.y + 1, self.rect.width, self.rect.height)
            
        self.text = ""
        Window.onRender(self, event)
        
        client = self.getTextRect()
        self.manager.sprite.drawText(text, client.x, client.y, client.width, client.height, 
            self.textColor, self.textFlags)
        
        #Restore.
        self.rect = rect
        self.color = color
        self.text = text
    

class _ChoiceWindow(Window):
    def __init__(self, parent, rect):
        Window.__init__(self, parent, rect)
        self.resizable = False
        self.captionHeight = 0
        self._choice = None
        self._hover = 0
    
    def _resize(self):
        pad = self._choice.pad
        h = len(self._choice.choices) * (self.manager.sprite.textHeight + pad) + self.textPad[1] + self.textPad[3] 
        r = Rect(self.rect.x, self.rect.y, self.rect.width, h + 5)
        self.setRect(r)
    
    def _getItemAt(self, x, y):
        start = self.rect.y + self.textPad[1] + self.borderSize #5
        index = (y - start) // (self.manager.sprite.textHeight + self._choice.pad)
        index = d3d11x.clamp(index, 0, max(len(self._choice.choices) - 1, 0))
        return index
    
    def onMouseButton(self, event):
        if event.code == WM_LBUTTONDOWN:
            index = self._getItemAt(event.x, event.y)
            if self._choice.choices:
                event.sender = self._choice #Redirect the event.
                hit = self._choice.choices[index]
                self._choice.selected = index
                self._choice.text = unicode(hit)
                self._choice.onChoice(event, index, hit)
                self.hide()

    def onMouseMove(self, event):
        self._hover = self._getItemAt(event.x, event.y)
      
    def onRender(self, event):
        Window.onRender(self, event)
        
        pad = self._choice.pad
        textHeight = self.manager.sprite.textHeight + pad
        r = self.getTextRect()
        y = r.y
        for i, x in enumerate(self._choice.choices):
            if i == self._hover:
                hoverColor = self._adjustColor(self.color, event, 0.5) 
                self.manager.sprite.drawRect(r.x, y, r.width, textHeight, hoverColor, gradient=0.7)
                
            self.manager.sprite.drawText(unicode(x), r.x, y + pad // 2, r.width, 0, 
                self.textColor, flags=d3d11x.TEXT_SINGLELINE)
            y += textHeight
    
    def onLoseFocus(self, event):
        self.hide()
    
class Choice(Window):
    pad = 3
    
    #: All choice names in the control.
    choices = None
    #: Index of the currently selected item.
    selected = None

    def __init__(self, parent, rect):
        """Creates a new Choice."""
        self._choiceWindow = None
        Window.__init__(self, parent, rect)
        self.resizable = False
        self.captionHeight = 0
        
        self.choices = []
        self.selected = 0
        
        self._choiceWindow = _ChoiceWindow(self.manager, Rect(0, 0, 10, 10))
        self._choiceWindow._choice = self
        self._choiceWindow.hide()
 
        self.setRect(self.rect)
        
    def add(self, item):
        """Adds a new choice into the control."""
        if not self.choices:
            self.text = unicode(item) #First one.
        self.choices.append(item)
        self._choiceWindow._resize()
        
    def remove(self, index):
        """Removes a choice from the control."""
        del self.choices[index]
        self._choiceWindow._resize()
        
    def close(self):
        self._choiceWindow.close()
        Window.close(self)
        
    def setRect(self, rect):
        Window.setRect(self, rect)
        if self._choiceWindow:
            r = self.rect
            #Overlap slightly, looks better.
            self._choiceWindow.setRect(Rect(r.x, r.y + r.height - self.borderSize, r.width, r.height))
            self._choiceWindow._resize()
            
    def onGetFocus(self, event):
        #Make sure it is not disabled, for example
        #makeModal() will disable it because it
        #is an independent root window.
        self._choiceWindow.disable(False)
        
        #Show and give focus.
        self._choiceWindow.hide(False)    
        self._choiceWindow.giveFocus()
                
    def onChoice(self, event, index, item):
        """Called when the user has selected a value."""
        pass

    def onRender(self, event):
        r = self.rect
        sprite = self.manager.sprite
        color = self._adjustColor(self.color, event)
        if self is self.manager.getHoverWindow():
            color = _mulColor(color, 1.2)
        
        #Background and border.
        borderColor = self._adjustColor(self.borderColor, event)
        borderSize = self.borderSize
        sprite.drawRect(r.x, r.y, r.width, r.height, color, None, borderColor, borderSize, 0.5)
        
        #Arrow down
        arrowRect = sprite.getSpriteRect(GUI_IMAGE_DOWN)
        arrowx = r.x + r.width - arrowRect.width - 1
        arrowy = r.y + r.height // 2 - arrowRect.height // 2
        sprite.drawRect(arrowx, arrowy, arrowRect.width, 
            arrowRect.height, self._adjustColor((1, 1, 1, self.alpha), event), GUI_IMAGE_DOWN, gradient=0.7)

        #Separating line
        sprite.drawRect(arrowx - borderSize // 2, r.y + borderSize, 
            borderSize, r.height - borderSize * 2, borderColor)
        
        #Text
        client = self.getTextRect()
        sprite.drawText(self.text, client.x, client.y, client.width, client.height, 
            self.textColor, flags=d3d11x.TEXT_YCENTER | d3d11x.TEXT_SINGLELINE)
        
        
class _Group(Window):
    selectSize = (16, 16)
    borderSize = 1
    pad = 5
    
    def __init__(self, parent, rect):
        Window.__init__(self, parent, rect)
        self.resizable = False
        self.captionHeight = 0
        self._hover = None
        self._size = None
          
    def _getItemAt(self, x, y):
        start = self.rect.y + self.pad
        index = (y - start) // (self.manager.textHeight + self.pad)
        if index < 0 or index >= self._size:
            return None
        return index
       
    def _resize(self, size):
        self._size = size
        r = self.rect
        h = size * (self.manager.textHeight + self.pad) + self.pad
        self.setRect(Rect(r.x, r.y, r.width, h))
       
    def onMouseMove(self, event):
        self._hover = self._getItemAt(event.x, event.y)
        
    def onMouseLeave(self, event):
        self._hover = None
        
    def onMouseButton(self, event):
        if event.code == WM_LBUTTONDOWN:
            index = self._getItemAt(event.x, event.y)
            if index is not None:
                self._onSelect(event, index)
        
    def onRender(self, event):
        r = self.rect
        y = r.y + self.pad
        sprite = self.manager.sprite
        w, h = self.selectSize
        border = self.borderSize 
        color = self._adjustColor(self.color, event)
        borderColor = self._adjustColor(self.borderColor, event)
        boxGradient = 0.8
        #boxBackground = self._adjustColor((1, 1, 1, self.alpha), event)
        boxBackground = _mulColor(color, 0.5)
        
        for i in range(self._size):
            text, fill = self.onGetItem(i)
        
            #Center boxes vertically.
            boxy = y + (self.manager.textHeight // 2 - h // 2)

            #Darken colors if hovering.
            boxColor = color
            if self._hover is not None and i == self._hover:
                boxColor = _mulColor(color, 0.75)
            
            #Box background.
            sprite.drawRect(r.x + self.pad - border, boxy - border, 
                w + border * 2, h + border * 2, boxColor, None, borderColor, border, boxGradient)
            
            if fill:
                #Box selection texture.
                sprite.drawRect(r.x + self.pad, boxy, 
                    w, h, boxBackground, fill, gradient=0.6)
            
            realy = y + (self.manager.textHeight - self.manager.sprite.textHeight) // 2
            sprite.drawText(unicode(text), r.x + w + self.pad * 2, realy, r.width - w - 20, 0, self.textColor) #XX width pad..
            
            y += self.manager.textHeight + self.pad
         

class _CheckBox:
    def __init__(self, item, checked):
        self.item = item
        self.checked = checked
            
class CheckBoxGroup(_Group):
    #: All checkbox names in the control. All objects in the list have ``name`` and ``checked`` attributes.
    boxes = None

    def __init__(self, parent, rect):
        """Creates a new CheckBoxGroup."""
        _Group.__init__(self, parent, rect)
        self.boxes = []
        self._resize(len(self.boxes))
        
    def add(self, item, checked=False):
        """
        :param item: Label for the checkbox.
        :param checked: If True the checkbox will be initally checked.
    
        Adds a new checkbox into the control.
        """
        self.boxes.append(_CheckBox(item, checked))
        self._resize(len(self.boxes))
         
    def remove(self, index):
        """Removes a checkbox from the control."""
        del self.boxes[index]
        self._resize(len(self.boxes))
        
    def check(self, index, value=True):
        """Checks or unchecks a checkbox."""
        box = self.boxes[index]
        box.checked = value
        self.onCheck(Event(None, self), index, box.item, value)
        
    def _onSelect(self, event, i):
        box = self.boxes[i]
        box.checked = not box.checked
        self.onCheck(event, i, box.item, box.checked)
        
    def onCheck(self, event, index, item, value):
        """Called when a checkbox has been checked or unchecked."""
        pass
   
    def onGetItem(self, i):
        fill = None
        if self.boxes[i].checked:
            fill = GUI_IMAGE_CHECK
        return self.boxes[i].item, fill
        
 
class RadioGroup(_Group):
    #borderSize = 0

    def __init__(self, parent, rect):
        """Creates a new RadioGroup."""
        _Group.__init__(self, parent, rect)
        self.buttons = []
        self.selected = 0
        
    def add(self, item):
        """Adds a new radio button into the control."""
        self.buttons.append(item)
        self._resize(len(self.buttons))
            
    def remove(self, index):
        """Removes a radio button from the control."""
        del self.buttons[index]
        self._resize(len(self.buttons))
            
    def select(self, index):
        """Selects a radio button."""
        self.onSelect(Event(None, self), index, self.buttons[index])
        self.selected = index
            
    def _onSelect(self, event, i):
        self.selected = i
        self.onSelect(event, i, self.buttons[i])
        
    def onSelect(self, event, index, item):
        """Called when a radio item has been selected."""
        pass
        
    def onGetItem(self, i):
        fill = None
        if i == self.selected:
            fill = GUI_IMAGE_RADIO
        return self.buttons[i], fill
        
        
class Image(Window):
    borderSize = 0
    #: A ``flip``-argument for :meth:`d3d11x.Sprite.drawRect`.
    flip = None
    
    def __init__(self, parent, rect, imagepath, newsize=(0, 0), resize=True):
        """
        :param imagepath: Path to an image file which will be loaded into manager's sprite.
        :param newsize: The texture will be resized to this size when loading. (0, 0) means no resizing.
        :param resize: If True :meth:`~d3d11gui.Image.adjustSize` will be called and the
            control (not the texture) will be resized. There is nothing wrong in displaying
            "stretched" images, but it is not usually wanted and that is why this
            defaults to True.
            
        Creates a new Image.
        """
        Window.__init__(self, parent, rect)
        self.resizable = False
        self.captionHeight = 0
        self.color = (1, 1, 1, 1)
        self.flip = 0
        
        self.imageName = os.path.abspath(imagepath)
        texture = self.manager.sprite.loadTexture(self.imageName, self.imageName, newsize)
        self.imageSize = texture.size()
        
        if resize:
            self.adjustSize()

    def adjustSize(self):
        """
        Resizes the control so that it's pixels will map 1:1 to screen pixels. 
        Border size is taken into account. You can call this when you have
        changed certain visual parameters (border size etc.). ::
        
            #Width and height are changed later, they don't really matter.
            image = Image(window, Rect(10, 10, 1, 1), "Textures/SomeImage.png")
            #We want a perfect pixel mapping with a border.
            image.borderSize = 1
            #Resize the control.
            image.adjustSize()
        """
        border = self.borderSize * 2
        self.resize(self.imageSize[0] + border, self.imageSize[1] + border)
        
    def onRender(self, event):
        r = self.rect
        color = self._adjustColor(self.color, event)
        borderColor = self._adjustColor(self.borderColor, event)
        self.manager.sprite.drawRect(r.x, r.y, r.width, r.height, 
            color, self.imageName, borderColor, self.borderSize, 1, self.flip)
            
        if self.text:
            textColor = self._adjustColor(self.textColor, event)
            self.manager.sprite.drawText(self.text, r.x, r.y, r.width, r.height, 
                textColor, d3d11x.TEXT_CENTER)
        
        
class Selector:
    #: Minimum value for the selector, zero based.
    start = None
    #: Maximum value for the selector, zero based, non-inclusive.
    stop = None
    #: Current position of the selector.
    position = None
    #: True if the selector is currently dragged by the user.
    dragged = None
    
    def __init__(self, start, stop, position=None):
        """
        :param start: Minimum index for the selector, zero based.
        :param stop: Maximum index for the selector, zero based, non-inclusive.
        :param position: Starting position for the selector. If None ``start`` is used.
        
        Creates a new Selector. 
        """
        self.start = start
        self.stop = stop
        self.position = self.start
        if position is not None:
            self.position = position
        self.dragged = False
      
class Slider(Window):
    pad = (25, 20)
    connectorColor = (0.7, 0.3, 0.3, Window.alpha)

    #: All selectors. Don't change the list itself, but you can modify it's items.
    selectors = None
    #: Maximum value for all selectors, non-inclusive.
    range = None

    drawConnectors = None
    """If True a line is draw between selectors if there are more than one. 
    They are assumed to form pairs (first-second, third-fourth etc.)."""
    
    def __init__(self, parent, rect):
        """
        Creates a new Slider. By default a slider increses the size of it's rectangle
        so that selectors are easier to drag with a mouse. If you don't want this you
        can set the class attribute: ``Slider.pad = (0, 0)``. That disables
        this behaviour. ::
        
            #Create a "normal" slider with one selector.
            slider1 = Slider(parent, Rect(10, 10, 200, 10))
            slider1.range = 50
            slider1.addSelector()
            
            #Create a slider with two selector so that the user can specify a range of values.
            slider2 = Slider(parent, Rect(10, 10, 200, 10))
            slider2.range = 100 #0-99, 100 possible positions.
            slider2.addSelector(Selector(0, 50)) #Range 0-49, 50 possible positions.
            slider2.addSelector(Selector(49, 100, 99)) #Range 49-99, 50 possible positions.  
        """
        rect.x -= self.pad[0] 
        rect.y -= self.pad[1]
        rect.width += self.pad[0] * 2
        rect.height += self.pad[1] * 2
        
        Window.__init__(self, parent, rect)
        self.resizable = False
        self.captionHeight = 0

        self.range = 2
        self.selectors = []
        self.drawConnectors = False
        
        area = self.manager.sprite.getSpriteRect(GUI_SLIDER)
        self.posSize = (area.width, area.height)
        
    def addSelector(self, selector=None):
        """Adds a new :class:`Selector` into the slider. If no 
        argument is given a default selector is created."""
        if selector is None:
            selector = Selector(0, self.range)
        self.selectors.append(selector)
        
    def removeSelector(self, index):
        """Removes a selector."""
        del self.selectors[index]
        
    def _getPosRect(self, i):
        r = self.rect
        add = self.posSize[0] // 2
        left = r.x + self.pad[0] - add
        right = r.x + r.width - self.pad[0] - self.posSize[0] + add
        width = right - left
        relative = self.selectors[i].position / float(self.range - 1) 
        x = left + int(round(width * relative))
        y = r.y  + r.height // 2 - self.posSize[1] // 2
        return Rect(x, y, self.posSize[0], self.posSize[1])
    
    def onMouseButton(self, event):
        if event.code == WM_LBUTTONDOWN:
            for i, s in enumerate(self.selectors):
                if self._getPosRect(i).pointInside(event.x, event.y):
                    s.dragged = True
                    break
        elif event.code == WM_LBUTTONUP:
            self._stopDrag()
        
    def _stopDrag(self):
        for s in self.selectors:
            s.dragged = False
        
    def onMouseMove(self, event):
        for s in self.selectors:
            if s.dragged:
                x = self.rect.x + self.pad[0]
                w = self.rect.width - self.pad[0] * 2 #- self.posSize[0]  XXX
                pos = min(max(event.x - x, 0), w) / float(w)
                index = int(round(pos * (self.range - 1)))
                index = d3d11x.clamp(index, s.start, s.stop - 1)
                
                if index != s.position:
                    s.position = index
                    self.onSlide(event, s)
                break
        
    def onSlide(self, event, selector): 
        """Called when a selector has moved."""
        pass
        
    def onGetLabel(self, event, selector):
        """
        Called during the rendering. This should return a string that will
        be drawn above or under the selector. By default this returns ``selector.position + 1`` 
        as a string.
        """
        return str(selector.position + 1)
        
    def onGetFocus(self, event):
        if len(self.selectors) > 1:
            Window.onGetFocus(self, event)
        
    def onMouseLeave(self, event):
        self._stopDrag()
        
    def onMouseWheel(self, event):
        if len(self.selectors) == 1:
            s = self.selectors[0]
            pos = d3d11x.clamp(s.position + event.wheel, s.start, s.stop - 1)
            if pos != s.position:
                s.position = pos
                self.onSlide(event, s)
        
    def onRender(self, event):
        sprite = self.manager.sprite
        color = self._adjustColor(self.color, event)
        borderColor = _mulColor(color, 1.25)
        sliderColor = _mulColor(color, 0.5)
        connectorColor = self._adjustColor(self.connectorColor, event)
        
        #Background.
        r = self.rect
        px, py = self.pad
        sprite.drawRect(r.x + px, r.y + py, r.width - px * 2, 
            r.height - py * 2, color, None, borderColor, 1, 0.8)
        
        prevRect = None
        #Selectors.
        for i, s in enumerate(self.selectors):
            pos = self._getPosRect(i)
            scolor = sliderColor
            if s.dragged:
                scolor = _mulColor(sliderColor, 0.5)
            #Selector.
            sprite.drawRect(pos.x, pos.y, pos.width, pos.height, scolor, GUI_SLIDER, gradient=0.6)
        
            label = self.onGetLabel(event, s)
            w = self.rect.width
            
            texty = pos.y - self.posSize[1]
            if i % 2 != 0:
                #Change text y-position for every second selector.
                texty = pos.y + self.posSize[1] + 5
            
            #Label.
            sprite.drawText(label, pos.x + self.posSize[0] // 2 - w // 2, texty, w, 0, 
                self.textColor, flags=d3d11x.TEXT_SINGLELINE | d3d11x.TEXT_XCENTER)
 
            #Connector between two selector.
            if self.drawConnectors and i % 2 == 1:
                x = prevRect.x + self.posSize[0]
                #y = r.y + self.pad[1] + 2 
                y = pos.y + self.posSize[1] // 2
                w = pos.x - x
                if w > 0:
                    sprite.drawRect(x, y, w, 2, connectorColor) 

            prevRect = pos

SCROLL_X = 0x01
SCROLL_Y = 0x02
       
class ScrollData:
    #: Maximum value for the selector, zero based, non-inclusive.
    range = None
    step = None
    """The meaning of this value is up to the user. In the default :meth:`ScrollBar.onScroll` handler
    this value is used to determine how much the controls are moved with each scroll. """
    #: Current position of the scroll bar.
    position = None
    #: True if the selector is currently dragged by the user.
    dragged = None
    #: Either SCROLL_X or SCROLL_Y. 
    axis = None
    
    def __init__(self, range, step, axis):
        """
        :param range: Maximum position for the scrollbar, zero based, non-inclusive.
        :param step: See the attribute description.
        :param axis: SCROLL_X or SCROLL_Y
        
        Creates a new ScrollData. 
        """
        self.range = range
        self.step = step
        self.position = 0
        self.dragged = False
        self.axis = axis
       
    def copy(self):
        """Creates a new copy from self."""
        data = ScrollData(self.range, self.step, self.axis)
        data.position = self.position
        data.dragged = self.dragged
        return data
       
class ScrollBar(Window):
    barSize = 20

    def __init__(self, parent, rect, flags=SCROLL_X|SCROLL_Y, attach=True):
        """
        :param flags: A combination of scroll flags (SCROLL_X, SCROLL_Y).
        :param attach: If True :meth:`attach` is called automatically.

        Creates a new ScrollBar.
        """
        Window.__init__(self, parent, rect)
        self.resizable = False
        self.captionHeight = 0
        
        #self.scrollers = [Scroller(10, 10), Scroller(10, 10)]
        self.scrollers = [None, None]
        if flags & SCROLL_X:
            self.setScrollData(ScrollData(1, 10, SCROLL_X))
        if flags & SCROLL_Y:
            self.setScrollData(ScrollData(1, 10, SCROLL_Y))
        
        self.alpha = 0.9
        #self.color = self.color[:3] + (self.alpha, )
        
        self._attached = False
        self.flags = flags
        if attach:
            self.attach()
 
    def attach(self):
        """
        Attaches the ScrollBar to it's current parent window. Note that once a scrollbar
        has been attached to a window the scrollbar should not be removed (altough 
        it can be hidden).
        """
        assert(self._attached == False)
        
        #Hook some methods.
        self.parent.giveFocus = self._giveFocusParent
        self.parent.onResize = self._onResizeParent
        self.parent.getTextRect = self._getTextRectParent
        self.parent._onRenderInternal = self._onRenderInternalParent
         
        self._onResizeParent(Event(None, self.parent))
        
        #First for hit testing.
        self.parent.children.remove(self)
        self.parent.children.insert(0, self)
        
        self._attached = True
        self._hideChildren(0, 0)
        
    def _giveFocusParent(self):
        self.giveFocus()
        
    def _getTextRectParent(self):
        r = self.parent.__class__.getTextRect(self.parent) 
        if not self.hidden:
            if self.flags & SCROLL_X:
                r.height -= self.barSize #X subtracts from .height
            if self.flags & SCROLL_Y:
                r.width -= self.barSize 
        return r
        
    def _onResizeParent(self, event):
        self.parent.__class__.onResize(self.parent, event)
        pr = self.parent.getClientRect()
        self.setRect(pr)
        self._hideChildren(0, 0)
        
    def _getBarRect(self, axis):
        #Returns the whole scrollbar axis rect.
        r = self.rect
        space = 0
        if self.flags & SCROLL_X and self.flags & SCROLL_Y:
            space = self.barSize 
            
        if axis == SCROLL_X:
            y = r.y + r.height - self.barSize 
            return Rect(r.x, y, r.width - space, self.barSize)
        elif axis == SCROLL_Y:
            x = r.x + r.width - self.barSize 
            return Rect(x, r.y, self.barSize, r.height - space)
    
    def _getBarButtons(self, axis):
        bar = self._getBarRect(axis)
        if axis == SCROLL_X:
            left = Rect(bar.x, bar.y, self.barSize, self.barSize)
            right = Rect(bar.x + bar.width - self.barSize, bar.y, self.barSize, self.barSize)
            return left, right 
        elif axis == SCROLL_Y:
            top = Rect(bar.x, bar.y, self.barSize, self.barSize)
            bottom = Rect(bar.x, bar.y + bar.height - self.barSize, self.barSize, self.barSize)
            return top, bottom
    
    def _getScrollerRect(self, axis):
        minsize = 10 #Minmum size for the controller in pixels.
        borderTotal = 0 #1 * 4 
        s = self._getScrollData(axis)
        relative = s.position / float(s.range)
        
        #Compute the scroller rectangle. There is much
        #that affects this from control size to axis range.
        #TODO: merge them, they are almost the same.
        
        if axis == SCROLL_X:
            left, right = self._getBarButtons(SCROLL_X)
            width = (right.x - (left.x + left.width)) - borderTotal
            size = float(max(minsize, width / float(s.range)))
            dif = size - (width / float(s.range)) 
            finalsize = width - dif 
            x = left.x + self.barSize + ((relative * finalsize) - size)
            return Rect((x + size), left.y, (size + borderTotal), self.barSize)
        elif axis == SCROLL_Y:
            top, bottom = self._getBarButtons(SCROLL_Y)
            height = (bottom.y - (top.y + top.height)) - borderTotal
            size = float(max(minsize, height / float(s.range)))
            dif = size - (height / float(s.range)) 
            finalsize = height - dif 
            y = top.y + self.barSize + ((relative * finalsize) - size)
            return Rect(top.x, (y + size), self.barSize, (size + borderTotal))
        
    def setScrollData(self, data):
        """Sets :class:`ScrollData`. Axis is taken from the ``data``."""
        #oldData = self.scrollers[data.axis-1]
        #if oldData:
            #Scroll to new position using old settings.
        #    self.scrollTo(data.position, data.axis)
        self.scrollers[data.axis-1] = data.copy()
    
    def getScrollData(self, axis):
        """
        Returns the :class:`ScrollData` from the given axis or None. The returned
        object is a copy and can be modified.
        """
        return self.scrollers[axis-1].copy()
    
    def _getScrollData(self, axis):
        #For internal use, return a reference.
        return self.scrollers[axis-1]
    
    def scrollTo(self, position, axis):
        """Scrolls to a specific position."""
        s = self._getScrollData(axis)
        delta = position - s.position 
        self.scroll(delta, axis)
    
    def scroll(self, amount, axis):
        """Scrolls a relative amount from current position."""
        s = self._getScrollData(axis)
        oldPos = s.position
        newPos = d3d11x.clamp(s.position + amount, 0, s.range - 1)
        if newPos != oldPos:
            s.position = newPos
            self.onScroll(Event(None, self), s, newPos - oldPos)

    def onMouseWheel(self, event):
        for axis in (SCROLL_Y, SCROLL_X):
            if self.flags & axis:
                #print(event.wheel)
                self.scroll(-event.wheel, axis)
                break
          
    def _hideChildren(self, xmove, ymove):
        #Hide all children that are outside parent's
        #client rectangle.
        clientRect = self.parent.getClientRect() 
        for child in self.parent.children:
            if child is not self:
                r = child.rect
                child.setRect(Rect(r.x + xmove, r.y + ymove, r.width, r.height))
                
                if clientRect.intersects(child.rect):
                    #Child is visible.
                    child.hide(False)
                else:
                    child.hide(True)
          
    def onScroll(self, event, scroller, amount):
        """
        Called when a scrollbar has been moved. By default parent's child windows
        are moved when scrolling. You can override this behaviour. Also when child
        windows are outside the parent's client rectangle they are hidden (for
        performace reasons).
        """
        if not self._attached:
            return
    
        xmove = 0
        ymove = 0
        if scroller.axis == SCROLL_X:
            xmove = -amount * scroller.step
        elif scroller.axis == SCROLL_Y:
            ymove = -amount * scroller.step
            
        self._hideChildren(xmove, ymove)
                
    def hitTest(self, x, y, area):
        if self.hidden:
            return
        if area == HIT_WINDOW:
            for axis in (SCROLL_X, SCROLL_Y):
                if self.flags & axis:
                    if self._getScrollData(axis).dragged:
                        return self.rect.pointInside(x, y)
                
                    if self._getBarRect(axis).pointInside(x, y):
                        return True
                        
        return False
    
    def onMouseButton(self, event):
        if event.code == WM_LBUTTONDOWN:
            for axis in (SCROLL_X, SCROLL_Y):
                if self.flags & axis:
                    #First scrollbar buttons.
                    for i, button in enumerate(self._getBarButtons(axis)):
                        if button.pointInside(event.x, event.y):
                            move = 1
                            if i == 0:
                                move = -1
                            self.scroll(move, axis)
                            return
                            
                    #Then scrollers.
                    scroller = self._getScrollerRect(axis)
                    if scroller.pointInside(event.x, event.y):
                        self._getScrollData(axis).dragged = True
                        return
                         
                    #Then background.
                    delta = 0
                    ssize = 1
                    bar = self._getBarRect(axis)
                    if bar.pointInside(event.x, event.y):
                        if axis == SCROLL_X:
                            delta = event.x - (scroller.x + self.barSize // 2)
                            ssize = scroller.width
                        elif axis == SCROLL_Y:
                            delta = event.y - (scroller.y + self.barSize // 2)
                            ssize = scroller.height
                                  
                    #self.scroll(int(d3d11x.clamp(delta, -1, 1)), axis)
                    self.scroll(int(round(delta / ssize)), axis)
                                  
        elif event.code == WM_LBUTTONUP:
            for s in self.scrollers:
                if s:
                    s.dragged = False
             

    def onMouseMove(self, event):
        for axis in (SCROLL_X, SCROLL_Y):
            if self.flags & axis:
                scrolldata = self._getScrollData(axis)
                if scrolldata.dragged:
                    srect = self._getScrollerRect(axis)
                    
                    #Calculate the delta from scrollbar start
                    #and scroll to that position.
                    
                    if axis == SCROLL_X:
                        bar = self._getBarRect(SCROLL_X)
                        barTotal = bar.width - self.barSize * 2
                        delta = event.x - (bar.x + self.barSize)
                    elif axis == SCROLL_Y:
                        bar = self._getBarRect(SCROLL_Y)
                        barTotal = bar.height - self.barSize * 2
                        delta = event.y - (bar.y + self.barSize)
                        
                    relative = d3d11x.clamp(float(delta) / barTotal, 0.0, 1.0)
                    self.scrollTo(int(relative * scrolldata.range), axis)
                    return
    
    def _onRenderInternalParent(self, dragged, disabled):
        self.parent.__class__._onRenderInternal(self.parent, dragged, disabled)
        
        #Hack, hack. This is done so that ScrollBar is always
        #the last window to be drawn.
        
        if self.hidden or (self.parent and self.parent.collapsed or self.parent.hidden):
            return
        
        event = Event(None, self)
        event.dragged = dragged
        event.disabled = disabled
        self._onRenderLast(event)
    
    def onRender(self, event):
        pass
    
    def _onRenderLast(self, event):
        #color = self._adjustColor(self.captionColor, event)
        color = self._adjustColor(self.color, event, 0.8)
        
        #bgcolor = self._adjustColor(self.color, event)
        borderColor = self._adjustColor(self.borderColor, event)
        if self.parent is self.manager.focusWindowRoot:
            color = _mulColor(color, 1.1)
        
        baseButtonColor = self._adjustColor(self.color, event, 0.8)
        
        isHovering = self is self.manager.getHoverWindow()
        sprite = self.manager.sprite
        gradient = 1 #0.8

        #rotations = (-90, 90, 0, 180)
        
        for ix, flag in enumerate((SCROLL_X, SCROLL_Y)):
            if self.flags & flag:
                #Background bars.
                bar = self._getBarRect(flag)
                sprite.drawRect(bar.x, bar.y, bar.width, bar.height, color, None, borderColor, 1, gradient)
                
                xoff = 0
                yoff = 2
                if flag == SCROLL_Y:
                    xoff = 2
                    yoff = 0
                
                #Buttons.
                for ib, button in enumerate(self._getBarButtons(flag)):
                    buttonColor = _mulColor(color, 0.5) 
                    if isHovering and button.pointInside(*self.manager.mousePos):
                        buttonColor = _mulColor(buttonColor, 1.4)
                
                    sprite.drawRect(button.x + 2, button.y + 2, button.width - 4, 
                        button.height - 4, buttonColor, gradient=0.75)
                
                    #sprite.drawRect(button.x + 1, button.y + 1, button.width - 2, 
                    #    button.height - 2, buttonColor, None, buttonBorder, 1)
                    #sprite.drawRect(button.x + 1, button.y + 1, button.width - 2, 
                    #    button.height - 2, buttonColor, GUI_IMAGE_UP, rotation=math.radians(rotations[ix*2+ib]))
        
        
                #Indicators.
                scroller = self._getScrollerRect(flag)
                scolor = _mulColor(color, 0.8) # baseButtonColor #borderColor
                if self._getScrollData(flag).dragged:
                    scolor = _mulColor(scolor, 0.9)
                elif isHovering and scroller.pointInside(*self.manager.mousePos):
                    scolor = _mulColor(scolor, 1.1)
                
                sprite.drawRect(scroller.x + xoff, scroller.y + yoff, 
                    scroller.width - xoff * 2, scroller.height - yoff * 2, scolor, None, buttonColor, 1, gradient)
        
        #Bottom-right patch.
        if self.flags & SCROLL_X and self.flags & SCROLL_Y:
            r = self.rect
            bsize = self.barSize
            sprite.drawRect(r.x + r.width - bsize, r.y + r.height - bsize, bsize, bsize, color, gradient=gradient)
        
BAR_X = 1
BAR_Y = 2
        
class ProgressBar(Window):
    #: Current position. This can be from 0.0 to 1.0 (inclusive).
    position = None
    throbber = None
    """If True the progress bar will be animated to show to the user that
    something is happening but that it is unknown how long it will take."""
    #: How fast the throbber should be moving. 
    throbberSpeed = None
    #: This will be returned from :meth:`onGetLabel` in throbber mode.
    throbberText = None
    title = None
    """This will be returned from :meth:`onGetLabel` in normal mode. The
    string should contain one format character (%i) for an integer."""
    
    def __init__(self, parent, rect):
        """Creates a new ProgressBar."""
        Window.__init__(self, parent, rect)
        self.resizable = False
        self.captionHeight = 0
        
        self.orientation = BAR_X
        
        self.position = 0.0
        self.throbber = False
        self.throbberSpeed = 2.0
        self.throbberText = "Processing..."
        self.title = "%i%%"
        self._throbPos = 0
        self._throbDir = 1
        
    def onGetLabel(self, event):
        """
        Called during the rendering. This should return a string that will
        be drawn inside the progress bar. You probably want to return different
        values if ``self.throbber`` is True.
        """
        if self.throbber:
            return self.throbberText
        else:
            return self.title % round(self.position * 100.0)
        
    def onRender(self, event):
        color = self._adjustColor(self.color, event)
        borderColor = self._adjustColor(self.borderColor, event)
        sprite = self.manager.sprite
        gradient = 0.7
        border = self.borderSize
        r = self.rect
        
        sprite.drawRect(r.x, r.y, r.width, r.height, color, None, self.borderColor, border, gradient)
        
        width = (r.width - border * 2)
        if self.throbber:
            block = int(width / 5.0)
            
            self._throbPos += (self._throbDir * self.throbberSpeed) * self.manager.frameSpeed 
            x = r.x + self._throbPos
            
            if x > r.x + width - block + border:
                self._throbDir = -1
            if x < r.x + border:
                self._throbDir = 1
            
            tcolor = self._adjustColor((0, 0.5, 0, self.alpha), event)
            sprite.drawRect(x, r.y + border, block, r.height - border * 2, tcolor, gradient=gradient)
            
        else:
            width = width * self.position
            sprite.drawRect(r.x + border, r.y + border, width, r.height - border * 2, 
                (0, 0.5, 0, self.alpha), gradient=gradient)
        
        label = self.onGetLabel(Event(None, self))
        sprite.drawText(label, r.x, r.y, r.width, r.height, self.textColor, flags=d3d11x.TEXT_CENTER)
        
        
        
class _Caret:
    def __init__(self):
        self.line = 0
        self.index = 0
        self.x = 0
     
class _Selection:
    def __init__(self):
        self.start = None
        self.end = None
     
class TextBox(Window):
    #: A list of all lines in the control.
    lines = None
    #: If True no line breaks are allowed.
    singleline = None

    def __init__(self, parent, rect, scrolling=SCROLL_Y):
        """
        :param scrolling:  If not 0 a scrollbar will be added. Only
            vertical (SCROLL_Y) scrolling is currently supported.
        
        Creates a new TextBox.
        """
        self.lines = [STR()]
        self.caret = _Caret()
        self.selection = _Selection()
        self._blink = 0
        self._linescroll = 0
        self._clicktime = 0.0
        self._mousedown = False
        self.scrollbar = None
        self.separators = set(" -[](),;.:") 
        self.singleline = False
        
        Window.__init__(self, parent, rect)
        self.resizable = False
        self.captionHeight = 0
        
        if scrolling:
            oldgivefocus = self.giveFocus
            self.scrollbar = ScrollBar(self, Rect(0, 0, 1, 1), scrolling)
            self.scrollbar.onScroll = self._onScrollScrollbar
            self.scrollbar.onGetFocus = self._onGetFocusScrollbar
            self.giveFocus = oldgivefocus
        
    def _getText(self):
        return STR("\n").join(self.lines)
        
    def _setText(self, text):
        self.clear()
        self.insertText(text)
        
    text = property(_getText, _setText)
        
    def _onGetFocusScrollbar(self, event):
        self.giveFocus()
        
    def _onScrollScrollbar(self, event, data, dir):
        self._linescroll = max(self._linescroll + dir, 0)
        
    def onGetCursor(self, event):
        if self.getTextRect().pointInside(event.x, event.y):
            return IDC_IBEAM
        
    def clear(self):
        """Clears the box from all content."""
        self.stopSelection()
        self.lines = [STR()]
        self.setCaret(0, 0)
        
    def insertText(self, text):
        """Inserts text at the current caret position."""
        text = self._filterText(text)
        if len(text) == 0:
            return
            
        self.eraseSelected()
    
        line = self.caret.line
        index = self.caret.index
        
        old = self.lines[line] 
        new = old[:index] + text + old[index:]
        
        oldLineCount = len(self.lines)
        
        self.lines[line] = new
        self._splitLine(line)
        
        self._moveCaret(len(text))
         
        self.onChange(Event(None, self))
         
  
    def _moveCaret(self, step):
        #Move caret forward.
        caretLine = self.caret.line
        caretIndex = self.caret.index
        
        lineLen = len(self.lines[caretLine])
        if caretIndex >= lineLen:
            caretIndex = caretIndex - lineLen
            caretLine += 1
        
        for x in range(step):
            if caretLine >= len(self.lines):
                break
        
            caretIndex += 1
            
            if caretIndex > len(self.lines[caretLine]):
                caretIndex = 1
                caretLine += 1

        self.setCaret(caretLine, caretIndex)
        
    def _findWordLimits(self, text, i):
        start = min(len(text) - 1, i)
        end = i

        #Find start index.
        while start > 0:
            c = text[start]
            category = unicodedata.category(c)[0]
            if category == "Z" or c in self.separators:
                start = start + 1
                break
            start = start - 1
    
        #Find end index.
        while end < len(text):
            c = text[end]
            category = unicodedata.category(c)[0]
            if category == "Z" or c in self.separators:
                break
            end = end + 1
        
        return start, end 
          
    def _splitLine(self, i):
        line = self.lines[i]
        sprite = self.manager.sprite

        linesize = sprite.getTextSize(line)[0]
        client = self.getTextRect()
        if linesize > client.width or line.find("\n") != -1:
            #Split the line.
            lines = [""]
            prevWasSpace = True
            x = 0
            i = 0
            while i < len(line):
                c = line[i]
                
                if c == "\n":
                    lines[-1] += " "
                    if self.singleline:
                        c = " "
                    else:
                        lines.append(STR())
                        x = 0
                        i += 1
                        continue
                
                x += sprite.getCharSize(c)[0]
            
                if prevWasSpace and not c.isspace() and not self.singleline:
                    #Starts a word
                    wordEnd = line.find(" ", i)
                    if wordEnd == -1:
                        wordEnd = None
                        
                    word = line[i:wordEnd]
                    wordSize = sprite.getTextSize(word)[0]
                    
                    if x + wordSize > client.width - self.textPad[2]: 
                        #Overflows width.
                        if line.find(" ") != -1:
                            #Line has a space, so split it.
                            lines.append(STR())
                            x = 0
                          
                #Add the character to the last line.
                lines[-1] += c
                i += 1
            
                prevWasSpace = c.isspace()

            caret = self.caret.line
            self.lines[caret:caret+1] = lines
                
    def _filterText(self, text):
        text = STR(text)
        ok = []
        for c in text:
            if unicodedata.category(c)[0] != "C" or c == "\n":
                ok.append(c)
        return STR().join(ok)
              
    def eraseSelected(self):
        """Erases all selected text (if any)."""
        start, end = self.getSelection()
        if start:
            begin = self.lines[start[0]][:start[1]]
            rest = self.lines[end[0]][end[1]:]
            
            #Delete all full lines between.
            del self.lines[start[0]:end[0]+1]
                
            #Add the combined line.
            self.lines[start[0]:start[0]+0] = [begin + rest]

            self.setCaret(start[0], start[1])
            self.stopSelection()
            
            self._splitLine(start[0])

            self.onChange(Event(None, self))
            
    def stopSelection(self):
        """Stops text selection."""
        #self.selection.start = None
        self.selection.end = None
                    
    def setCaret(self, line, index):
        """Moves the caret to the given position. Both arguments will 
        be clamped if outside the valid range."""
        self.caret.line = d3d11x.clamp(line, 0, len(self.lines) - 1)
        self.caret.index = d3d11x.clamp(index, 0, len(self.lines[self.caret.line]))  
        text = self.lines[self.caret.line][:self.caret.index]
        self.caret.x = self.manager.sprite.getTextSize(text)[0] + 1
            
        if self.scrollbar:
            #Move the scrollbar so that the caret is visible.
            linecount = self.getTextRect().height // self.manager.sprite.textHeight
        
            #Use the internal method.
            self.scrollbar._getScrollData(SCROLL_Y).range = max(len(self.lines) - linecount + 1, 1)
            
            if self.caret.line < self._linescroll:
                self.scrollbar.scrollTo(self.caret.line, SCROLL_Y)
            elif self.caret.line >= self._linescroll + linecount:
                self.scrollbar.scrollTo(self.caret.line - linecount + 1, SCROLL_Y) 
                         
    def getLineAt(self, x, y):
        """Returns the line index at given screen coordinates. The returned index
        will be clamped if outside the valid range."""
        assert(self.rect.pointInside(x, y))
        client = self.getTextRect()
        lineindex = (y - client.y) / self.manager.textHeight 
        return int(d3d11x.clamp(lineindex + self._linescroll, 0, len(self.lines) - 1))
                     
    def setCaretAt(self, x, y):
        """Sets the caret at the given screen coordinates."""
        client = self.getTextRect()
        lineindex = self.getLineAt(x, y)
             
        charindex = 0
        width = client.x
        distance = abs(x - width)
        for c in self.lines[lineindex]:
            width += self.manager.sprite.getCharSize(c)[0]
            newdistance = abs(x - width)
            if newdistance > distance:
                break
                
            distance = newdistance 
            charindex += 1
        
        self.setCaret(lineindex, charindex)
             
    def getSelection(self):
        """Returns the text selection data ``(start, end)``. If no text is selected both values
        will be None. Otherwise they are tuples: ``(lineindex, charindex, xcoordinate)``."""
        if self.selection.end:
            start = self.selection.start
            end = self.selection.end
            
            #If start is smaller than end swap them.
            swap = False
            if start[0] > end[0]:
                swap = True
            if start[0] == end[0] and start[1] > end[1]:
                swap = True
                
            if swap:
                start, end = end, start
                
            return start, end
        return None, None
         
    def getSelectedText(self):
        """Returns selected text or None if no text is selected."""
        start, end = self.getSelection()
        if start:
            lines = []
            for i in range(start[0], end[0] + 1):
                line = self.lines[i]
                a = None
                b = None
                if i == start[0]:
                    a = start[1]
                if i == end[0]:
                    b = end[1]
                lines.append(line[a:b])
            return STR("\n").join(lines)
        return None
             
    def onMouseButton(self, event):
        if event.code == WM_LBUTTONDOWN:
            self._blink = 0
            self._mousedown = True
            
            #For double click timing.
            newtime = time.clock()
            delta = newtime - self._clicktime
            self._clicktime = newtime
            
            #Position caret.
            self.setCaretAt(event.x, event.y)

            #Next check selection.
            self.selection.start = (self.caret.line, self.caret.index, self.caret.x)
            self.selection.end = None
           
            if delta < 0.25:
                #Double click, select a word.
                line = self.lines[self.caret.line]
                start, end = self._findWordLimits(line, self.caret.index)
                
                linestartw = self.manager.sprite.getTextSize(line[:start])[0]
                self.selection.start = (self.caret.line, start, linestartw)
                
                selected = line[start:end]
                selectedw = self.manager.sprite.getTextSize(selected)[0]
                fullw = self.manager.sprite.getTextSize(line[:end])[0]
                self.selection.end = (self.caret.line, end, fullw)
                
                self.setCaret(self.caret.line, end)

                #Prevents mouse move handler to mess selection.
                self._mousedown = False
                 
        elif event.code == WM_LBUTTONUP:
            self._mousedown = False
                     
    def onMouseMove(self, event):
        if self._mousedown:
            self._blink = 0
        
            self.selection.end = None
            self.setCaretAt(event.x, event.y)
            end = (self.caret.line, self.caret.index, self.caret.x)  
            if end[0] == self.selection.start[0] and end[1] == self.selection.start[1]:
                #No selection.
                pass
            else:
                self.selection.end = end
 
    def onMouseWheel(self, event):
        if self.scrollbar:
            self.scrollbar.onMouseWheel(event)
 
    def onChar(self, event):
        self.insertText(event.char)
        
    def onKey(self, event):
        self._blink = 0
        if event.code == WM_KEYDOWN:
            ctrldown = d3d11.isKeyDown(VK_CONTROL)
        
            if event.wparam == VK_LEFT:
                if self.caret.index == 0:
                    if self.caret.line > 0:
                        self.setCaret(self.caret.line - 1, len(self.lines[self.caret.line - 1]))
                else:
                    self.setCaret(self.caret.line, self.caret.index - 1)
                #self.moveCaret(-1)
            elif event.wparam == VK_RIGHT:
                if self.caret.index == len(self.lines[self.caret.line]):
                    if self.caret.line < len(self.lines) - 1:
                        self.setCaret(self.caret.line + 1, 0)
                else:
                    self.setCaret(self.caret.line, self.caret.index + 1)
                #self.moveCaret(1)
            elif event.wparam == VK_UP:
                self.setCaret(self.caret.line - 1, self.caret.index)
            elif event.wparam == VK_DOWN:
                self.setCaret(self.caret.line + 1, self.caret.index)
            elif event.wparam == ord("C") and ctrldown:
                text = self.getSelectedText()
                if text:
                    d3d11.setClipboardData(text)
            elif event.wparam in (VK_BACK, VK_RETURN, ord("V")):
                #Destructive input if selection.
                self.eraseSelected()

                lineindex = self.caret.line
                index = self.caret.index
                line = self.lines[lineindex]
            
                if event.wparam == VK_BACK:
                    if index > 0:
                        self.lines[lineindex] = line[:index-1] + line[index:]
                        self.setCaret(lineindex, index - 1)
                    elif index == 0 and lineindex > 0:
                        prevLine = self.lines[lineindex-1]
                        thisLine = self.lines[lineindex]
                        del self.lines[lineindex]
                        self.setCaret(lineindex - 1, len(prevLine))
                        self.insertText(thisLine)
                        self.setCaret(lineindex - 1, len(prevLine))
                elif event.wparam == VK_RETURN:
                    if not self.singleline:
                        oldline = line[:index]
                        newline = line[index:]
                        self.lines[lineindex] = oldline
                        self.lines.insert(lineindex + 1, newline)
                        self.setCaret(lineindex + 1, 0)   
                elif event.wparam == ord("V") and ctrldown:
                    text = d3d11.getClipboardData()
                    if text:
                        self.insertText(text)   
                       
                self.onChange(Event(None, self))
                       
    def onGetFocus(self, event):
        self._blink = 0
        
    def onChange(self, event):
        """
        Called when the contents of the text box have changed. This might be called
        several times and in certain cases no actual changes have occurred. This
        can happen if the user selects text and then pastes the same text. First the selected text
        is erased and then the new one is inserted. The contents did change but the end result
        is same.
        """
        pass
        
    def onRender(self, event):
        sprite = self.manager.sprite 
        color = self._adjustColor(self.color, event)
        borderColor = self._adjustColor(self.borderColor, event)
        r = self.rect
    
        #Backgound.
        sprite.drawRect(r.x, r.y, r.width, r.height, color, None, borderColor, self.borderSize, 0.5)
    
        client = self.getTextRect()
        y = client.y
        textHeight = self.manager.sprite.textHeight
        selection = self.getSelection()
        
        i = self._linescroll
        while i < len(self.lines):
            if y + textHeight > client.y + client.height:
                break
        
            if selection[0]:
                start, end = selection
                if i >= start[0] and i <= end[0]:
                    #Current line has selected text.
                    sx = client.x + start[2]
                    sw = end[2] - start[2]
                    if i == start[0] and i < end[0]:
                        #First selected line of many.
                        sw = client.x + client.width - sx
                    elif i > start[0] and i < end[0]:
                        #Fully selected line between start and end.
                        sx = client.x
                        sw = client.width
                    elif i == end[0] and i > start[0]:
                        #Last selected line of many.
                        sx = client.x
                        sw = end[2]
                    #Draw the selected background.
                    sprite.drawRect(sx, y, sw, textHeight, (0.2, 0.2, 0.2, 0.5))
        
            #Draw the text.
            sprite.drawText(self.lines[i], client.x, y, client.width, 0, self.textColor, d3d11x.TEXT_SINGLELINE)
            y += textHeight
            i += 1
    
        showcaret = False
        self._blink += 1 * self.manager.frameSpeed
        if self._blink < 30:
            showcaret = True
        elif self._blink > 60:
            self._blink = 0
    
        #Caret.
        if self is self.manager.getFocusWindow() and showcaret:
            carety = client.y + (self.caret.line - self._linescroll) * textHeight
            caretrect = Rect(client.x + self.caret.x - 1, carety, 1, textHeight)
            if self.rect.rectInside(caretrect):
                sprite.drawRect(caretrect.x, caretrect.y, caretrect.width, caretrect.height, (0, 0, 0, 1))
    
              
        
class MessageBox(Window):
    def __init__(self, parent, rect, flag):
        Window.__init__(self, parent, rect)
        self.resizable = False
    
        y = self.rect.height - 90
        height = int(self.manager.sprite.textHeight * 1.5)
        
        if flag == MB_OK:
            x = self.rect.width // 2 - 100 // 2
        
            self.ok = Button(self, Rect(x, y, 100, height))
            self.ok.text = "OK"
            self.ok.onClick = self._onOk
        elif flag == MB_OKCANCEL:
            x = self.rect.width // 4
        
            self.ok = Button(self, Rect(x, y, 100, height))
            self.ok.text = "OK"
            self.ok.onClick = self._onOk
        
            self.cancel = Button(self, Rect(x + 125, y, 100, height))
            self.cancel.text = "Cancel"
            #self.cancel.onClick = self._onOk
        
        self.makeModal()

    def _onOk(self, event):
        self.close()
        
        
class MenuItem:
    #: Item text.
    text = None
    #: A texture handle used with manager's sprite. Can be None.
    icon = None
    #: A list of (MenuItem) subitems.
    items = None

    def __init__(self, text):
        """Creates a new MenuItem with the given text."""
        self.text = text
        self.icon = None #GUI_IMAGE_X #None
        self.items = []
        
class Menu(Window):
    #: If True menu item icons are drawn. Set this before adding any items.
    hasIcons = False

    def __init__(self, parent, rect):
        """Creates a new Menu."""
        Window.__init__(self, parent, rect)
        self.resizable = False
        self.captionHeight = 0
        self.useClipRect = False
        self.alpha = 0.9
        
        self.items = []
        self.hasIcons = False
        
        self._hover = 0
        self._iconSize = 25
        
        if self.parent is None:
            self.giveFocus()
            
    def _resize(self):
        r = self.rect
        sprite = self.manager.sprite
        w = 5
        
        iconSize = 0
        if self.hasIcons:
            iconSize = self._iconSize
        
        h = self.textPad[1] + self.textPad[3]
        for item in self.items:
            newWidth = sprite.getTextSize(item.text)[0] + iconSize + self.textPad[0] + self.textPad[2] + 10 
            
            w = max(w, newWidth)
            h += sprite.textHeight
            
        self.setRect(Rect(r.x, r.y, w + self._iconSize, h))
        self._findGoodPosition()
        
    def getItemAt(self, x, y):
        ystart = self.getTextRect().y
        return d3d11x.clamp((y - ystart) // self.manager.sprite.textHeight, 0, len(self.items) - 1)
        
    def add(self, item):
        """Adds a new :class:`MenuItem` object into the menu."""
        self.items.append(item)
        self._resize()
        
    def onLoseFocus(self, event):
        self.close()
        
    def onMouseMove(self, event):
        self._hover = self.getItemAt(event.x, event.y)
        
        r = self.rect
        screenRect = Rect(0, 0, self.manager.client[0], self.manager.client[1])
        
        #Close all children.
        for child in self.children[:]:
            child.close()
        
        menu = self.items[self._hover]
        if menu.items:
            #Create a new submenu Menu.
            submenu = Menu(self, Rect(0, 0, 10, 10))
            submenu.hasIcons = self.hasIcons
            for item in menu.items:
                submenu.add(item)
            
            x = r.x + r.width
            y = r.y + self.textPad[1] + self._hover * self.manager.sprite.textHeight
            
            submenu.setRect(Rect(x, y, submenu.rect.width, submenu.rect.height))
            submenu._findGoodPosition()
            
    def _findGoodPosition(self):
        #Try to position the menu inside the screen rect.
        r = self.rect
        x = r.x
        y = r.y
        screen = self.manager.getScreenRect()
       
        if x + r.width > screen.width:
            if self.parent:
                x = self.parent.rect.x - r.width
            else:
                x -= r.width - 5

        if y + r.height > screen.height:
            if self.parent:
                y = screen.height - r.height - 5
            else:
                y -= r.height
    
        self.setRect(Rect(x, y, r.width, r.height))
            
    def hitTest(self, x, y, area):
        if self.hidden:
            return False
            
        if area == HIT_WINDOW or area == HIT_CLIENT:
            #Test against self and all child windows.
            for w in self.getAllChildren() + [self]:
                if w.rect.pointInside(x, y):
                    return True
        else:
            return Window.hitTest(self, x, y, area)
        
        return False
        
    def onSelect(self, event, index, menuitem):
        """Called when the users selects a menu item."""
        return
        
    def onMouseButton(self, event):
        if event.code == WM_LBUTTONDOWN:
            index = self.getItemAt(event.x, event.y)
            item = self.items[index]
            if item.items:
                #This is a submenu. XXX - bugs if more than one nested menu.
                pass
            else:
                root = self.getRoot()
                event.sender = root #Redirect.
                root.onSelect(event, index, item)
                
                self.getRoot().close()

    def onRender(self, event):
        r = self.rect
        sprite = self.manager.sprite
        color = self._adjustColor(self.color, event)
        borderColor = self._adjustColor(self.borderColor, event)
        
        #Background.
        sprite.drawRect(r.x, r.y, r.width, r.height, color, None, self.borderColor, 1, gradient=0.8)
        
        client = self.getTextRect()
        x = client.x
        w = client.width
        if self.hasIcons:
            x += self._iconSize
            w -= self._iconSize
        
        y = client.y
        rot = math.radians(90)

        for i, item in enumerate(self.items):
            if i == self._hover:
                #Hover background.
                hoverColor = self._adjustColor(self.color, event, 0.5) #1.1
                sprite.drawRect(client.x, y, client.width, sprite.textHeight, hoverColor)
        
            if item.items:
                #Submenu icon.
                sprite.drawRect(x + w - self._iconSize, y - 3, self._iconSize, self._iconSize, 
                    None, GUI_IMAGE_UP, rotation=rot)
        
            if item.icon:
                #Item icon.
                icony = y + sprite.textHeight // 2 - self._iconSize // 2
                sprite.drawRect(r.x + 2, icony, self._iconSize, self._iconSize, None, item.icon)
        
            #Item text.
            sprite.drawText(item.text, x, y, w, client.height, self.textColor)
            y += sprite.textHeight
        
        if self.hasIcons:
            #Separator line.
            lineColor = self._adjustColor(self.borderColor, event, 0.8)
            sprite.drawRect(r.x + self._iconSize + 1, client.y, 1, client.height + 1, lineColor)
        