
# Copyright (C) 2010, Heikki Salo
# All rights reserved.
#
# Distributed under the BSD license:
# http://www.opensource.org/licenses/bsd-license.php

#True division.
from __future__ import division

import sys
import os
import time
import math
import string
import unicodedata
import array
import threading 
import imp

import d3d11
from d3d11c import *

#Some Python 2.x - 3.x compatibility tweaks

try:
    import queue
except ImportError:
    import Queue as queue

if sys.version_info[0] >= 3:
    CHR = chr
    STR = str
else:
    CHR = unichr
    STR = unicode
  
#Functions

def loWord(v):
    """Returns the low order word of a integer value. Useful when handling window messages."""
    return (v & 0xffff)

def hiWord(v):
    """Returns the high order word of a integer value. Useful when handling window messages."""
    return (v >> 16) & 0xffff
   
def isMouseMessage(msg):
    """Returns True if the message is a mouse message."""
    return msg.code >= WM_MOUSEFIRST and msg.code <= WM_MOUSELAST
   
def isKeyMessage(msg):
    """Returns True if the message is a keyboard message."""
    return msg.code >= WM_KEYFIRST and msg.code <= WM_KEYLAST
   
def featureLevel(level):
    """Returns the value from :meth:`d3d11.Device.getFeatureLevel` as a tuple."""
    version = hex(level)
    return int(version[2], 16), int(version[3], 16)
    
def isMainFrozen():
    #From py2exe wiki: new py2exe, old py2exe or tools/freeze
    return hasattr(sys, "frozen") or hasattr(sys, "importers") or imp.is_frozen("__main__") 
    
def getResourceDir(*args):
    """
    Returns the default resource directory where effects, meshes, textures etc. are looked from.
    If any arguments are passed the function behaves similary to ``os.path.join``. ::
    
        path = getResourceDir("Effects", "MyEffect.fx")
    
    You can (and possibly should if you are using py2exe or anything similar) replace this function with your own version. ::
    
        def myGetResourceDir(*args):
            ... 
            return path
    
        #Do this before loading any d3d11x-objects.
        d3d11x.getResourceDir = myGetResourceDir
    """
    if isMainFrozen():
        path = os.path.dirname(sys.executable)
    else:
        try:
            #Try the directory where __main__ is.
            main = sys.modules["__main__"]
            path = os.path.dirname(os.path.abspath(main.__file__)) 
        except:
            #Use the current working directory.
            path = os.getcwd()
            
    path = os.path.normpath(os.path.join(path, *args))
    return path

def _nextPow2(k):
    assert(k >= 0)
    if k == 0:
        return 1
    return (2 ** math.ceil(math.log(k, 2)))
    
def clamp(v, minval=0.0, maxval=1.0):
    assert(maxval >= minval)
    if v < minval:
        v = minval
    if v > maxval:
        v = maxval
    return v
    
#Classes

class ThreadedLoader(object):
    def __init__(self):
        """Constucts a new ThreadedLoader. This is a relatively resource intensive object
        so you should usually create only one and store it for later use."""
        self.stop = False
        self.jobs = queue.Queue(0)
        self.errors = []
        
        self.runEvent = threading.Event()
        self.runEvent.set()
        
        try:
            threadcount = int(os.environ["NUMBER_OF_PROCESSORS"]) 
        except:
            threadcount = 2
            
        #Because there is alrady one main thread, create one
        #thread less. 
        threadcount = clamp(threadcount - 1, 1, 3) 
        
        self.threads = [] 
        for i in range(threadcount):
            thread = threading.Thread(target=self._threadRun)
            self.threads.append(thread)
            thread.start()
        
    def _threadRun(self):
        """Common thread function for all threads."""
        while not self.stop:
            self.runEvent.wait()

            job = None
            try:
                job = self.jobs.get_nowait()
            except queue.Empty:
                pass
        
            if job:
                #Got a job.
                try:
                    #Call the target and pass all arguments,
                    result = job[2](*job[3])
                    if job[0]:
                        setattr(job[0], job[1], result)
                except:
                    message = "'%s.%s' - %s" % (job[0], job[1], sys.exc_info()[1])
                    self.errors.append(message) #list.append() is thread safe on CPython...
                self.jobs.task_done() 
        
    def addJob(self, obj, attrname, klass, *args):
        """
        :param obj: An object which will receive the loaded object.
        :param attrname: ``obj``'s attribute name.
        :param target: A callable object (a class, function etc.).
        :param args: Any number of arguments, these will be passed to ``target``.
        
        .. warning::
        
            You should make sure that the target supports threaded
            loading (ie. is thread safe). This can be tricky to verify and
            failures can be very hard to track down. For example several d3d11x objects
            are safe only if you call ``<classname>.loadCache()`` or :meth:`Resource.loadCacheAll` 
            before adding them as jobs.
        
        Schedules a new job. ::
        
            #Threaded version.
            loader = ThreadedLoader()
            loader.addJob(self, "texture", d3d11.Texture, "Textures/sometexture.dds")
            loader.join()
            
            #Non-threaded version.
            self.texture = d3d11.Texture("Textures/sometexture.dds")
        """
        self.jobs.put((obj, attrname, klass, args))
          
    def wait(self):
        """
        Waits untill all jobs have finished. If an error occurred while processing 
        a job (in another thread) an exception will be raised. This method can be
        called many times.
        """
        self.jobs.join() #XXX test this.
        self.runEvent.clear()
        if len(self.errors) > 0:
            e = self.errors[0] #Take the first error, others are ignored.
            self.errors = []
            raise RuntimeError("Threaded loading error: %s" % e)
        
    def join(self):
        """
        This calls :meth:`wait` and closes all job threads. Don't use 
        the ThreadedLoader after calling this. 
        """
        self.wait()
    
        #Signal stop and wait for the threads to finish.
        self.stop = True
        self.runEvent.set()
        for thread in self.threads:
            thread.join()
            
        self.threads = None
        self.runEvent = None
        self.jobs = None
        

class Rect(object): 
    #: x-coordinate.
    x = None
    #: y-coordinate.
    y = None
    #: width
    width = None
    #: height
    height = None

    def __init__(self, x, y, width, height):
        """Creates a new Rect."""
        self.x = int(x)
        self.y = int(y)
        self.width = int(width)
        self.height = int(height)
    
    def copy(self):
        """Returns a copy of self."""
        return Rect(self.x, self.y, self.width, self.height)
    
    #def inflate(self, x, y):
    #    return Rect(self.x - x, self.y - y, self.width + x * 2, self.height + y * 2)
    
    def pointInside(self, x, y):
        """Returns True if the point is inside self."""
        if x >= self.x and x < self.x + self.width and y >= self.y and y < self.y + self.height:
            return True
        return False
        
    def rectInside(self, rect):
        """Returns True if ``rect`` is inside self."""
        if rect.x >= self.x and rect.x + rect.width <= self.x + self.width:
            if rect.y >= self.y and rect.y + rect.height <= self.y + self.height:
                return True
        return False
        
    def intersects(self, rect):
        """Returns True if ``rect`` intersects with self."""
        r1_left = self.x
        r1_top = self.y
        r1_right = self.x + self.width 
        r1_bottom = self.y + self.height 
        r2_left = rect.x
        r2_top = rect.y
        r2_right = rect.x + rect.width 
        r2_bottom = rect.y + rect.height 
        return not ((r2_left >= r1_right) or (r2_right <= r1_left) or (r2_top >= r1_bottom) or (r2_bottom <= r1_top))
        
    def setCenter(self, x, y):
        """Moves rectangles center point."""
        self.x = x - self.width // 2
        self.y = y - self.height // 2
        
    def getCenter(self):
        """Get rectangles center point."""
        x = self.x + self.width // 2
        y = self.y + self.height // 2
        return x, y
        
    def __eq__(self, b):
        return self.x == b.x and self.y == b.y and self.width == b.width and self.height == b.height
        
    def __ne__(self, b):
        return not self == b
        
    def __getitem__(self, i):
        #For tuple-like behaviour.
        return (self.x, self.y, self.width, self.height)[i]
        
    def __len__(self):
        return 4
        
    def __str__(self):
        return "Rect(%i, %i, %i, %i)" % (self.x, self.y, self.width, self.height)
        
        
class Mapper(object):
    def __init__(self, mapped, *args):
        self.mapped = mapped
        self.args = args
        
    def __enter__(self):
        self.mapped.map(*self.args)
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.mapped.unmap()
        return False

     
class Accessor(object):
    def __init__(self, data, size, byteSize):
        self.data = data
        self.size = size
        self.byteSize = byteSize
        
    def __getitem__(self, xy):
        startIndex = (xy[1] * self.size[0] + xy[0]) * self.byteSize
        assert(0) #Test startIndex
        return self.data[startIndex:startIndex+self.byteSize]
    
    def __setitem__(self, xy, value):
        assert(len(value) == self.byteSize)
        startIndex = xy[1] * self.size[0] + xy[0]
        self.data[startIndex:startIndex+self.byteSize] = value
    
    
class Resource(object):
    effectMacros = None
    """
    A dictionary which will be passed to :class:`~d3d11.Effect`'s constructor. For example
    if you want to use instancing with :class:`Mesh` you should set the ``MESH_MAX_INSTANCE_COUNT``
    *before* loading any meshes::
    
        #A batch group of 100 elements.
        Mesh.effectMacros["MESH_MAX_INSTANCE_COUNT"] = "100"
        #Load the first mesh, this also initializes the cache.
        m = Mesh(...)
    """
    
    effectName = None
    """
    The name .fx file which will be used to load the class's :class:`~d3d11.Effect`. The
    effect must naturally have a compatible input signature. Set this before loading any class
    objects. The full path will be retrieved by using :func:`d3d11x.getResourceDir`. ::
    
        #I want to use my own effect to render heightmaps.
        HeightMap.effectName = "HMap.fx"
        #Load the first HeightMap, this also initializes the cache.
        hmap = HeightMap(...)
    """
    
    @classmethod
    def loadCache(klass):
        """Loads class's cached resources if they are not already loaded."""
        if klass.effect is None:
            macros = klass.effectMacros
            if macros is None:
                macros = {}

            effectPath = getResourceDir("Effects", klass.effectName)
            klass.effect = d3d11.Effect(effectPath, klass.effectMacros) 
            klass.inputLayout = d3d11.InputLayout(klass.inputLayoutDesc, klass.effect, 0, 0) 
            
            #Call the static callback.
            if hasattr(klass, "_loadCache"):
                klass._loadCache()
    
    @staticmethod
    def loadCacheAll():
        """Loads all cached resources for every class that inherits from inherits from :class:`~d3d11x.Resource`."""
        Sprite.loadCache()
        Mesh.loadCache()
        HeightMap.loadCache()
        SkyBox.loadCache()
    
    @classmethod
    def clearCache(klass):
        """Clears class's cached resources."""
        klass.effect = None
        klass.inputLayout = None
        #Call the static method.
        if hasattr(klass, "_clearCache"):
            klass._clearCache()
    
    @staticmethod
    def clearCacheAll():
        """Clears all cached resources for every class that inherits from :class:`~d3d11x.Resource`."""
        Sprite.clearCache()
        Mesh.clearCache()
        HeightMap.clearCache()
        SkyBox.clearCache()
    
    @classmethod
    def setLights(klass, lights):
        """
        :param lights: A list which should contain 2-tuples which in turn should contain
            a 3-vector (light position) and a 4-vector (light color).
    
        Updates lightning information in an effect. ::
        
            #Red color at (0, 10, 0)
            lights = [((0, 10, 0), (1, 0, 0, 0))]
        
            m = d3d11x.Mesh(...)
            #Mesh inherits setLights() and because Mesh.effect is shared class
            #attribute this updates lights in all Mesh instances. You could
            #also use 'd3d11x.Mesh.setLights()', they do the same thing.
            m.setLights(lights)
        """
        positions = [] 
        colors = [] 
        for x in lights:
            positions.append(x[0])
            colors.append(x[1])
        
        lightsLen = len(lights)
        klass.effect.set("lightsActive", lightsLen)
    
        missing = 7 - lightsLen #Hardcoded
        if missing > 0:
            positions.extend([(0,0,0)] * missing)
            colors.extend([(0,0,0,0)] * missing)
    
        klass.effect.set("lightPositions", positions)
        klass.effect.set("lightColors", colors)
    
#16 and 32 bit indices.
indexLayoutDesc16 = [("", 0, FORMAT_R16_UINT, 0, 0, INPUT_PER_VERTEX_DATA, 0)]
indexLayoutDesc32 = [("", 0, FORMAT_R32_UINT, 0, 0, INPUT_PER_VERTEX_DATA, 0)]
    
#Used by Mesh and HeightMap
meshLayoutDesc = [
    ("POSITION", 0, FORMAT_R32G32B32_FLOAT, 0, 0, INPUT_PER_VERTEX_DATA, 0),
    ("NORMAL", 0, FORMAT_R32G32B32_FLOAT, 0, APPEND_ALIGNED_ELEMENT, INPUT_PER_VERTEX_DATA, 0), 
    ("TEXTURE", 0, FORMAT_R32G32_FLOAT, 0, APPEND_ALIGNED_ELEMENT, INPUT_PER_VERTEX_DATA, 0), 
]

#By default a 4x4 matrix.
meshInstanceDesc = [
    ("", 0, FORMAT_R32G32B32A32_FLOAT, 0, 0, INPUT_PER_VERTEX_DATA, 0),
    ("", 0, FORMAT_R32G32B32A32_FLOAT, 0, APPEND_ALIGNED_ELEMENT, INPUT_PER_VERTEX_DATA, 0),
    ("", 0, FORMAT_R32G32B32A32_FLOAT, 0, APPEND_ALIGNED_ELEMENT, INPUT_PER_VERTEX_DATA, 0),
    ("", 0, FORMAT_R32G32B32A32_FLOAT, 0, APPEND_ALIGNED_ELEMENT, INPUT_PER_VERTEX_DATA, 0),
]
    
class Mesh(Resource):
    inputLayoutDesc = meshLayoutDesc[:]
    instanceLayoutDesc = meshInstanceDesc[:]
    
    instanceBuffer = None
    inputLayout = None
    #: A cached and shared :class:`~d3d11.Effect` object. 
    effect = None
    effectName = "d3d11x-Mesh.fx"
    effectMacros = {"MESH_MAX_INSTANCE_COUNT" : "50"}
    
    #: A texture :class:`~d3d11.View` used in rendering.
    textureView = None
    
    def __init__(self, device, path):
        """
        :param device: A :class:`d3d11.Device`.
        :param path: File path to a mesh file.
        
        Creates a Mesh.
        """
        vertices, indices = self._loadObj(path)    
   
        #Any callback processing.
        vertices, indices = self.onLoad(vertices, indices)
   
        assert(len(indices) % 3 == 0) #Triangle lists.
   
        #Buffers always reads sequences, even if it has only one element.
        indices = [(x,) for x in indices]
      
        #16- or 32-bit indices?
        indexDesc = indexLayoutDesc16
        if len(vertices) >= 0xffff:
            indexDesc = indexLayoutDesc32
                 
        self.boundingBox = self._calculateBB(vertices)
        self.vertexBuffer = d3d11.Buffer(meshLayoutDesc, vertices, BIND_VERTEX_BUFFER, USAGE_IMMUTABLE)
        self.indexBuffer = d3d11.Buffer(indexDesc, indices, BIND_INDEX_BUFFER, USAGE_IMMUTABLE)
        #Always one subset.
        self.subsets = [(len(self.indexBuffer), 0)]
        self.device = device
        self.textureView = None

        self.loadCache()
  
    def onLoad(self, vertices, indices):
        """
        :param vertices: A vertex list.
        :param indices: An index list.
        :returns: This callback should return a vertex- and indexlist.
        
        This will be called when the geometry has been loaded. You can modify
        the arguments lists or create new ones, returned lists will be used to
        construct the internal vertex- and indexbuffer.
        """
        return vertices, indices
  
    @staticmethod
    def _loadCache(): 
        count = int(Mesh.effectMacros["MESH_MAX_INSTANCE_COUNT"])
        Mesh.instanceBuffer = d3d11.Buffer(meshInstanceDesc, count, BIND_CONSTANT_BUFFER)
        Mesh.instanceBuffer.resize(count)
             
    @staticmethod
    def _clearCache():
        Mesh.instanceBuffer = None
            
    def getSize(self):
        """
        :returns: width, height, depth (x-, y- and z-axis)
        
        Returns the size of the mesh.
        """
        w = self.boundingBox[1].x - self.boundingBox[0].x
        h = self.boundingBox[1].y - self.boundingBox[0].y 
        d = self.boundingBox[1].z - self.boundingBox[0].z 
        return w, h, d
          
    def getBoundingBox(self):
        """
        :returns: mincorner, maxcorner
        
        Returns the axis-aligned bounding box as two vectors (corners of the box).
        """
        return self.boundingBox
          
    def _calculateBB(self, vertices):
        minx = miny = minz = 1000000000.0
        maxx = maxy = maxz = -1000000000.0
        for v in vertices:
            minx = min(minx, v[0])
            maxx = max(maxx, v[0])
            
            miny = min(miny, v[1])
            maxy = max(maxy, v[1])
            
            minz = min(minz, v[2])
            maxz = max(maxz, v[2])
          
        return d3d11.Vector(minx, miny, minz), d3d11.Vector(maxx, maxy, maxz)
          
    def _loadObj(self, path):
        cache = {}
        vertices = []
        indices = []
        v = []
        vt = []
        vn = []
        
        for line in open(path):
            values = line.split()[1:]
            
            if line.startswith("v "):
                #Vertex positions.
                pos = [float(x) for x in values]
                pos[0] = -pos[0] #Flip x
                v.append(pos)
            elif line.startswith("vt "):
                #Texture coordinates.
                tex = [float(x) for x in values]
                tex[1] = 1.0 - tex[1] #Flip tv
                vt.append(tex)
            elif line.startswith("vn "):
                #Vertex normals.
                normal = [float(x) for x in values]
                normal[0] = -normal[0] #Flip x
                vn.append(normal)
            elif line.startswith("f "): 
                #Faces.
                if len(values) == 3:
                    pass #Ok
                elif len(values) == 4:
                    #Split the face into two triangles.
                    values = [values[0], values[1], values[2],values[0], values[2], values[3]]
                else:
                    raise RuntimeError("Invalid mesh face")
                
                assert(len(values) == 3 or len(values) == 6)
                
                for pointers in values:
                    faceIndices = pointers[:pointers.rfind("/")] #Ignore normals
                    if faceIndices in cache:
                        #Use an existing vertex.
                        indices.append(cache[faceIndices])
                    else:
                        #Create a new vertex.
                        iPos, iTex, iNorm = [int(x) for x in pointers.split("/")]
                        index = len(vertices)
                        indices.append(index)
                        
                        newVertex = tuple(v[iPos-1] + vn[iNorm-1] + vt[iTex-1])
                        vertices.append(newVertex)

                        cache[faceIndices] = index 
                            
        return vertices, indices
        
    def _updateObjects(self):
        self.device.setVertexBuffers([self.vertexBuffer])
        self.device.setIndexBuffer(self.indexBuffer)
        self.device.setPrimitiveTopology(PRIMITIVE_TOPOLOGY_TRIANGLELIST)
        self.device.setInputLayout(self.inputLayout)
        
        if self.textureView:
            self.effect.set("defaultTexture", self.textureView)
        
    def render(self, worldMatrix, viewMatrix, projMatrix, override=None):
        """
        :param override: A :class:`d3d11.DeviceState` which can be used to override
            effect settings.
        
        Renders the mesh using the given matrices.
        """
        self._updateObjects()
        self.effect.set("worldMatrix", worldMatrix)
        self.effect.set("viewProjection", viewMatrix * projMatrix)
        self.effect.apply(0, 0)
        if override is not None:
            self.device.setState(override)
        
        for subset in self.subsets:
            self.device.drawIndexed(subset[0], subset[1], 0)
        
    def renderInstanced(self, instanceData, viewMatrix, projMatrix, override=None):
        """
        :param instanceData: A sequence of instance data. 
        :param override: A :class:`d3d11.DeviceState` which can be used to override
            effect settings.
            
        Renders the mesh using instancing. World matrix is not required because it is assumed
        that position data will be read from ``instanceData``. This uses constant buffer
        instancing because it does not require input layout changes (there are other
        ways ways to do instancing, some of which are more flexible).
        """
        self._updateObjects()
        
        self.effect.set("viewProjection", viewMatrix * projMatrix)
        self.effect.set("instanceBuffer", self.instanceBuffer)
        self.effect.apply(1, 0)
        if override is not None:
            self.device.setState(override)
        
        #Because 'instanceBuffer' has a fixed capacity we must
        #draw thing in batches if 'len(instanceData) > len(instanceBuffer)'.
        #Vertex buffer instancing would be much more flexible,
        #this is a pretty horrible way to do it.
        maxInstanceCount = self.instanceBuffer.capacity()
        instaceCount = len(instanceData)
        i = 0
        while i < instaceCount:
            packet = instanceData[i:i+maxInstanceCount]
            packetLen = len(packet)
            missing = maxInstanceCount - packetLen
            if missing > 0:
                #Constant buffer must be updated() completely.
                #In this case the data does not matter, but it
                #must be there, so replicate the last element.
                packet.extend([packet[-1]] * missing)
            
            assert(len(packet) == maxInstanceCount)
            self.instanceBuffer.update(packet)
            
            for subset in self.subsets:
                self.device.drawIndexedInstanced(subset[0], maxInstanceCount, subset[1], 0, 0)
        
            i += maxInstanceCount

            
skyBoxLayoutDesc = [
    ("POSITION", 0, FORMAT_R32G32B32_FLOAT, 0, 0, INPUT_PER_VERTEX_DATA, 0),
    ("TEXTURE", 0, FORMAT_R32G32B32_FLOAT, 0, APPEND_ALIGNED_ELEMENT, INPUT_PER_VERTEX_DATA, 0), 
]
        
SKYBOX_BOX = 1
SKYBOX_CYLINDER = 2
       
class SkyBox(Resource):
    #Cached objects.
    effect = None
    effectName = "d3d11x-SkyBox.fx"
    inputLayout = None
    inputLayoutDesc = skyBoxLayoutDesc[:]

    def __init__(self, device, radius=100.0, style=SKYBOX_BOX, steps=14):
        """
        :param radius: Skybox radius.
        :param style: SKYBOX_BOX or SKYBOX_CYLINDER.
        :param steps: How many steps the cyliner will have. Only used if ``style`` is SKYBOX_CYLINDER.
    
        Creates a new SkyBox. After this you should also set the ``.textureView``-attribute.
        """
        self.style = style

        yBegin = 0.0
        verts = []
        
        if style == SKYBOX_CYLINDER:
            circum = math.pi * (2.0 * radius)
            height = circum / 4.0

            for i in range(steps):
                angle = (2 * math.pi * i) / (steps - 1)
                
                x = math.sin(angle) * radius
                z = math.cos(angle) * radius
                xtex = float(i) / ((steps - 1) * 1.501)
                
                #Lower.
                verts.append((x, yBegin, z, xtex, 1.0, 0.0))
                #Upper
                verts.append((x, yBegin + height, z, xtex, 0.0, 0.0))
    
        elif style == SKYBOX_BOX:
            height = radius * 2
        
            #Walls.
            offsets = ((-radius, radius), (radius, radius), (radius, -radius), (-radius, -radius), (-radius, radius))
            for i, xy in enumerate(offsets):
                tex = i / 6.001 #Not 6.0, prevents "texture leaks" from sky area.
                verts.append((xy[0], yBegin, xy[1], tex, 1.0, i))
                verts.append((xy[0], yBegin + height, xy[1], tex, 0.0, i))     
        
            #Roof
            xstep = 1.0 / 6.0
            tx = 1.0 / 1.5
            verts.extend(self._makePlane(yBegin + height, radius, tx, tx + xstep, index=4))
            #Floor 
            tx = tx + xstep
            verts.extend(self._makePlane(yBegin, radius, tx, tx + xstep, 1.0, 0.0, 5))
    
        self.textureView = None #d3d11.View(texture)
        self.buffer = d3d11.Buffer(skyBoxLayoutDesc, verts, BIND_VERTEX_BUFFER, USAGE_IMMUTABLE)
        self.device = device
        self.height = height
        
        self.loadCache()
        
    def _makePlane(self, y, radius, xstart, xend, ystart=0.0, yend=1.0, index=0):
        xstart = xstart * 1.0001
        xend = xend * 0.9999
    
        a = (-radius, y, radius, xend, ystart, index)
        b = (radius, y, radius, xstart, ystart, index)
        c = (-radius, y, -radius, xend, yend, index)
        d = (radius, y, -radius, xstart, yend, index)
        return (a, b, c, d)
          
    def render(self, world, view, proj):
        """Renders the skybox using the given matrices."""
        self.device.setVertexBuffers([self.buffer])
        self.device.setInputLayout(self.inputLayout)
        self.device.setPrimitiveTopology(PRIMITIVE_TOPOLOGY_TRIANGLESTRIP)
        
        self.effect.set("worldViewProjection", world * view * proj)
        self.effect.set("defaultTexture", self.textureView)
        self.effect.apply(0, 0)
        
        if self.style == SKYBOX_CYLINDER:
            self.device.draw(len(self.buffer), 0)
        else:
            #Walls.
            self.device.draw(10, 0)
            #Top and bottom.
            self.device.draw(4, 10)
            self.device.draw(4, 14)
            
        self.device.restoreDepthStencilState()
          
#Default height function for HeightMap
def heightFunc(x, z, byteIndex, data):
    return data[byteIndex] * 0.2 
        
class HeightMap(Resource):
    effect = None
    effectName = "d3d11x-HeightMap.fx"
    inputLayout = None
    inputLayoutDesc = meshLayoutDesc[:]
    
    def __init__(self, device, path, size=(0, 0), func=None, scales=(1.0, 1.0, 1.0), texrepeat=(1.0, 1.0), normalize=True):
        """
        :param device: A :class:`~d3d11.Device`.
        :param path: File path to a texture. Can be None.
        :param size: Size of the 2D-grid.
        :param func: Callback function to compute height at given points. If None a default function is used.
        :param scales: Scaling in each axis.
        :param texrepeat: Texture repeat count in x and z-axis. A mirrored texture sampler is used by default but you can change it
            if you want to use tiling textures etc.
        :param normalize: If True vertex normals are computed. Otherwise they are left as (0, 1, 0). 
            Computing normals can be quite time consuming when using large maps. If you are using
            precomputed normal maps in the pixel shader you might not need this.
        
        Creates a new HeightMap.
        """
        if func is None:
            func = heightFunc
        
        data = None #Texture data, if any.
        itemSize = 1 #Texture item size in bytes.
        width, height = size
        self.textureView = None
        self.device = device
        
        if path is not None:
            #Use a texture.
            texture = d3d11.Texture(path, size + (1, 1), 
                FORMAT_R8G8B8A8_UNORM, 0, USAGE_STAGING, CPU_ACCESS_READ)
            with Mapper(texture, MAP_READ):
                data = texture[::, ::] #Read everything.
    
            itemSize = texture.getItemSize()
            width, height = texture.size()
    
        #Temporary stuff.
        vertices = []
        indices = []
        xdif = 0.0 - (width / 2.0) * scales[0]
        ydif = 0.0 - (height / 2.0) * scales[2]
        xtexrepeat = texrepeat[0] #float(width - 1) * texrepeat[0]
        ytexrepeat = texrepeat[1] #float(height - 1) * texrepeat[1]
        
        #Data.
        self.heights = array.array("f") #Saves some space.
        self.width = width
        self.height = height
        self.scaling = d3d11.Vector(scales)
        
        for y in range(height):
            yindex = y * (width * itemSize)
            for x in range(width):
                byteIndex = yindex + (x * itemSize)

                #Height
                h = func(x, y, byteIndex, data) * scales[1]
                self.heights.append(h)
                
                #Texture coordinates
                tx = (x / (width - 1)) * xtexrepeat
                ty = (y / (height - 1)) * ytexrepeat
                
                vertices.append([xdif + x * scales[0], h, ydif + y * scales[2], 0, 1, 0, tx, ty])

                if x < width - 1 and y < height - 1:
                    index = y * width + x
                    #First triangle
                    indices.append(index)  
                    indices.append(index + 1) 
                    indices.append(index + width)  
                    #Second triangle
                    indices.append(index + width)
                    indices.append(index + 1)  
                    indices.append(index + width + 1)  

        if normalize:
            self._computeNormals(vertices)
 
        #Check before callback.
        assert(len(vertices) == width * height)
        assert(len(indices) == (width - 1) * (height - 1) * 6)
 
        #Callback
        vertices, indices = self.onLoad(vertices, indices)
        assert(len(indices) % 3 == 0) #Triangle lists.
 
        #Convert to sequence.
        indices = [(i, ) for i in indices]
 
        self.vertexBuffer = d3d11.Buffer(self.inputLayoutDesc, vertices, BIND_VERTEX_BUFFER, USAGE_IMMUTABLE)
        self.indexBuffer = d3d11.Buffer(indexLayoutDesc32, indices, BIND_INDEX_BUFFER, USAGE_IMMUTABLE)
        self.textureView = None
    
        self.loadCache()
    
    def onLoad(self, vertices, indices):
        """
        :param vertices: A vertex list.
        :param indices: An index list.
        :returns: This callback should return a vertex- and indexlist.
        
        This will be called when the geometry has been loaded. You can modify
        the arguments lists or create new ones, returned lists will be used to
        construct the internal vertex- and indexbuffer.
        """
        return vertices, indices
    
    def _computeNormals(self, vertices):
        offsets = ((-1, 0), (0, 1), (1, 0), (0, -1))
        
        #Ray normal "direction".
        directionUp = d3d11.Vector(0, 1, 0)
        
        #Local optimization.
        triNormal = d3d11.Vector.triNormal
        width = self.width
        height = self.height
        
        for i, v in enumerate(vertices):
            x = i % width
            y = i // width
        
            vertexPos = d3d11.Vector(v[0], v[1], v[2])
            normals = [directionUp]
        
            #Loop through every neighbour vertex.
            for offset in offsets:
                nx = x + offset[0]
                ny = y + offset[1]
                if nx >= 0 and nx < width and ny >= 0 and ny < height:
                    #This is a valid vertex.
                    nearVertex = vertices[(ny * width) + nx]
                
                    direction1 = vertexPos.direction(nearVertex)
                    crossed = direction1.cross(directionUp)
                    sideVector = vertexPos + crossed
                    
                    normal = triNormal(vertexPos, nearVertex, sideVector)
                    normals.append(normal)
        
            #Compute the average normal.
            result = d3d11.Vector(0, 0, 0)
            for n in normals:
                result += n / float(len(normals))
        
            #Replace the normal.
            v[3:6] = -result.normalize()
    
    def pointInside(self, x, z, border=0.0):
        """Returns True if the point is inside the height map. """
        halfWidth = (self.width * self.scaling.x / 2.0) - border
        halfHeight = (self.height * self.scaling.z / 2.0) - border
        if x > 0.0 - halfWidth and x < 0.0 + halfWidth:
            if z > 0.0 - halfHeight and z < 0.0 + halfHeight:
                return True
        return False
    
    def getArea(self):
        """
        :returns: xmin, zmin, xmax, zmax
        
        Returns area limits.
        """
        halfWidth = self.width * self.scaling.x / 2.0
        halfHeight = self.height * self.scaling.z / 2.0
        return -halfWidth, -halfHeight, halfWidth, halfHeight

    def _heightLookup(self, x, z):
        return self.heights[int(z * self.width + x)] 
    
    def getHeight(self, x, z):
        """Returns the (interpolated) height at given point."""
        assert(self.pointInside(x, z))
        
        #Uses bilinear interpolation.
        area = self.getArea()
        u = (x + area[2]) / (area[2] * 2) * self.width 
        v = (z + area[3]) / (area[3] * 2) * self.height 

        xIndex = math.floor(u)
        zIndex = math.floor(v)

        uRatio = u - xIndex
        vRatio = v - zIndex
        
        uOpposite = 1.0 - uRatio
        vOpposite = 1.0 - vRatio
        
        #Result from four points.
        tex = self._heightLookup
        result = (
            (tex(xIndex, zIndex)     * uOpposite + tex(xIndex + 1, zIndex)     * uRatio) * vOpposite +
            (tex(xIndex, zIndex + 1) * uOpposite + tex(xIndex + 1, zIndex + 1) * uRatio) * vRatio
        )
        return result

    def render(self, world, view, proj):
        """Renders the height map using the given matrices."""
        self.device.setVertexBuffers([self.vertexBuffer])
        self.device.setIndexBuffer(self.indexBuffer)
        self.device.setPrimitiveTopology(PRIMITIVE_TOPOLOGY_TRIANGLELIST)
        self.device.setInputLayout(self.inputLayout)
        
        self.effect.set("worldMatrix", world)
        self.effect.set("viewProjection", view * proj)
        if self.textureView:
            self.effect.set("defaultTexture", self.textureView)
        
        self.effect.apply(0, 0)
        
        self.device.drawIndexed(len(self.indexBuffer), 0, 0)
    
    
_fontLayoutDescGS = [
    ("POSITION", 0, FORMAT_R32G32B32A32_FLOAT),
    ("COLOR", 0, FORMAT_R32G32B32A32_FLOAT), 
    ("TEXAREA", 0, FORMAT_R32G32B32A32_FLOAT), 
    ("MISC", 0, FORMAT_R32G32B32A32_FLOAT),
    ("ROTATION", 0, FORMAT_R32_FLOAT),
]
      
TEXT_ITALIC = 0x1
TEXT_UNDERLINE = 0x2
TEXT_STRIKEOUT = 0x4
TEXT_SINGLELINE = 0x08 
TEXT_XCENTER = 0x10
TEXT_YCENTER = 0x20
TEXT_CENTER = TEXT_XCENTER | TEXT_YCENTER | TEXT_SINGLELINE
     
SPRITE_ARRAYSIZE = 2
assert(SPRITE_ARRAYSIZE > 1)
     
FLIP_X = 0x1
FLIP_Y = 0x2
FLIP_BOTH = FLIP_X | FLIP_Y
     
class Sprite(Resource):
    #Cached objects.
    effect = None
    effectName = "d3d11x-Sprite.fx"
    inputLayout = None
    inputLayoutDesc = _fontLayoutDescGS[:]
    
    #: Maximum height of a character.
    textHeight = None
    
    _specialAlways = CHR(0x20AC) #Euro
    
    def __init__(self, device, fontname="Arial", fontsize=16, fontweight=0, antialiased=True, specials="", minsize=(512, 512)):
        """
        :param device: A :class:`~d3d11.Device`.
        :param fontname: Name of the font. If this is None the sprite does not have any text drawing support.
        :param fontsize: Size of the font.
        :param fontweight: Weight of the font. 0 means you don't care, otherwise it can be between 1 and 900.
        :param antialiased: If True the font will be antialiased. This might of might not cause some minor
            artifacts (small "leaked" black pixels here and there). 
        :param specials: Any special characters to include. Because storing all unicode characters into
            a texture would require a lot of memory, by default only printable characters in range 0-255
            are included along with some common ones (eg. euro - 0x20AC).
        :param minsize: Minmum size for the internal texture. If you plan to load many other textures into
            it you might want to increse the size. 
    
        Constucts a new Sprite.
        """
        if fontname is not None:
            #Create a font texture.
            self.texture = self._generateFontTexture(fontname, fontsize, fontweight, antialiased, specials, minsize)
            self.textHeight = self.mapping["X"][3] 
            self.missingWidth = self.mapping["?"][2] 
        else:
            self.texture = d3d11.Texture(None, (minsize[0], minsize[1], SPRITE_ARRAYSIZE, 1), FORMAT_B8G8R8A8_UNORM)
            
        self.textureView = d3d11.View(self.texture) 
        #self.texture.save("font_out.dds", IFF_DDS) #Debugging.
        
        #Where it is safe to add other sprites.
        self.safeFonty = self._getFillStatus()[1] + 5
        
        self.loadCache()
  
        self.buffer = d3d11.Buffer(self.inputLayoutDesc, 2048, BIND_VERTEX_BUFFER, USAGE_DYNAMIC, CPU_ACCESS_WRITE)
        self.device = device
     
        #Compute the white pixel (1, 1, 1, ?) data. It is used when
        #no texture is wanted - multiplying 1 with 1 does nothing.
        #It is always at the top left corner.
        size = self.texture.size()
        px = 1.0 / size[0] 
        py = 1.0 / size[1] 
        self.whitePixel = (0.0, 0.0, px, py)
     
    def _generateFontTexture(self, name, fontsize, weight, antialiased, specials, minsize):
        #Generate all common latin characters.
        combined = []
        for i in range(256):
            c = CHR(i)
            category = unicodedata.category(c) 
            if category[0] == "C": #Control character, 3.x supports c.isprintable()...
                continue
            combined.append(c)  
        chars = STR().join(sorted(set(STR().join(combined) + specials + self._specialAlways)))
         
        #Approximate a good size for the texture. If it is too small _initFont() 
        #will throw an exception. Needs more testing.
        height = len(chars) * (fontsize + 2) # 2 is padding.
        width = fontsize 
        size = int(math.sqrt(height * width))
        #size = max(size, SPRITE_TEX_SIZE)
        w = max(size, minsize[0])
        h = max(size, minsize[1])
        #Create a GDI compatible texture.
        gdiTexture = d3d11.Texture(None, (w, h, 1, 1), FORMAT_B8G8R8A8_UNORM, 
            BIND_RENDER_TARGET | BIND_SHADER_RESOURCE, USAGE_DEFAULT, 0, RESOURCE_MISC_GDI_COMPATIBLE)
        tempView = d3d11.View(gdiTexture)
        tempView.clearRenderTarget()
        
        #Write characters into the texture and receive the mapping data.
        quality = 3 #NONANTIALIASED_QUALITY
        if antialiased:
            quality = 4 #ANTIALIASED_QUALITY
        charset = 0 #ANSI_CHARSET
        self.mapping = d3d11._initFont(gdiTexture, name, fontsize, weight, quality, charset, chars)
        
        return self._convertTexture(gdiTexture)
     
    def _convertTexture(self, source):
        desc = source.getDesc()
        w = desc.size[0]
        h = desc.size[1]
        textureArray = d3d11.Texture(None, (w, h, SPRITE_ARRAYSIZE, 1), desc.format)
        textureArray.copyRegion(0, 0, w, h, 0, 0, source, 0, 0)
        return textureArray
     
    def findSpace(self, w, h, padding):
        """
        This method attempts to find free space from the internal texture. This is useful if you want
        to add some new sprites for drawing. If this is successful a :class:`~d3d11x.Rect` specifying
        the valid area and an index into the internal texture array is returned. If no free space is found
        an exception is raised. This method is not very optimized and can be slow when using large 
        textures with a lot of content. Also see :meth:`~d3d11x.Sprite.loadTexture`.
        """
        size = self.texture.getDesc().size
        #if w > size[0] or h > size[1]:
            #Can never fit.
        #    return None, None
        
        for array in range(size[2]):
            xmove = 100 #XXX None etc.
            ymove = 100
            rects = []
            for k, v in self.mapping.items():
                assert(len(v) == 8 or len(v) == 9)
            
                arrayIndex = 0
                if len(v) == 9:
                    arrayIndex = v[8]
                
                if arrayIndex == array and len(k) > 1:
                    #This is a user given name.
                    rect = Rect(*v[:4])
                    xmove = max(min(xmove, rect.width), 12)
                    ymove = max(min(ymove, rect.height), 12)            
                    rects.append(rect)
        
            x = padding
            y = padding
            if array == 0:
                y = self.safeFonty
            
            while 1:
                r = Rect(x, y, w, h)
                x += xmove + padding
                
                ok = True
                if r.x + r.width > size[0]:
                    #x-overflow.
                    x = padding
                    y += ymove + padding
                    ok = False
                    
                if r.y + r.height > size[1]:
                    #y-overflow, break out and fail (or try the 
                    #next texture in the array).
                    break

                for r2 in rects:
                    if r.intersects(r2):
                        #Can't fit in here.
                        ok = False
                        break
                        
                if ok:
                    assert(r.x + r.width <= size[0] and r.y + r.height <= size[1])
                    return r, array
        #No space.
        raise RuntimeError("No texture space for the new texture")
     
    def _checkName(self, name):
        if name in self.mapping:
            raise RuntimeError("Texture handle already used")
        if len(name) <= 1:
            raise RuntimeError("Texture handle must be longer than one character")
     
    def updateTexture(self, destx, desty, w, h, srcx, srcy, texture, destindex=1, srcindex=0, handle=None):
        """
        :param handle: See :meth:`~d3d11x.Sprite.loadTexture`.
    
        Updates the internal texture. For other parameters see :meth:`~d3d11.Texture.copyRegion`. 
        """
        if texture.getDesc().format != FORMAT_B8G8R8A8_UNORM:
            raise RuntimeError("Texture format must be FORMAT_B8G8R8A8_UNORM")
            
        self._checkName(handle)
        self.texture.copyRegion(destx, desty, w, h, srcx, srcy, texture, destindex, srcindex)
        self.makeSprite(handle, Rect(destx, desty, w, h), destindex)
     
    def loadTexture(self, path, handle, size=(0, 0), padding=2):
        """
        :param path: Texture's file path.
        :param handle: A string which can be used in :meth:`~Sprite.drawRect` as the ``texture``-argument
            if this method succeeds. You can treat is as a handle to the internal texture area. 
        :param size: If not (0, 0) the texture will be resized to this size when loaded.
        :param padding: Padding for the texture in pixels. If you pack textures too closely some filters
            might pick color data from other nearby textures.
    
        This loads a texture from a file and copies it into the internal texture. Returned :class:`~d3d11.Texture`
        can be ignored. This is a convenience method which internally calls :meth:`~Sprite.findSpace` and
        :meth:`~Sprite.updateTexture`. 
        """
        temp = d3d11.Texture(path, size + (1, 1), FORMAT_B8G8R8A8_UNORM)
        w, h = temp.size()
        r, index = self.findSpace(w, h, padding)
        self.updateTexture(r.x, r.y, r.width, r.height, 0, 0, temp, index, 0, handle)
        self.device.flush()      
        time.sleep(0.005) #XXX - Hack, hack, hack.
        return temp

    def _getFillStatus(self):
        #How much of the texture (array index 0) is actually used.
        x = 0
        y = 0
        for k, v in self.mapping.items():
            x = max(x, v[0] + v[2])
            y = max(y, v[1] + v[3])
        
        size = self.texture.size()
        ratio = float(x * y) / (size[0] * size[1]) # 1.0 would be optimal.
        return x, y, ratio
      
    def getSpriteRect(self, handle):
        """Returns the given sprite's internal texture area as a :class:`Rect`."""
        data = self.mapping[handle]
        return Rect(data[0], data[1], data[2], data[3])
      
    def getSpriteCoords(self, handle):
        return self.mapping[4:8]
      
    def makeSprite(self, handle, rect, textureindex=0, parent=None):
        """
        :param handle: A new handle to be created. If this method succeeds this will be a valid handle.
    
        This can be used to create a handle into a internal texture area. For example if you have
        uploaded a big texture which contains smaller subimages you can use this method to
        create handles which refer only to a small part of that texture. You usually pass the
        original sprite handle as parent - this will make ``rect`` relative to the ``parent``-handle's area
        and ``textureindex`` will be taken from the parent data. 
        """
        self._checkName(handle)
    
        size = self.texture.size()
        if parent:
            #Relative to the "parent" sprite.
            data = self.mapping[parent]
            textureindex = data[8]
            r = Rect(data[0] + rect.x, data[1] + rect.y, rect.width, rect.height)
        else:
            r = rect
      
        w = float(size[0]) 
        h = float(size[1]) 
      
        #Texture coordinates.
        texx1 = r.x / w
        texx2 = (r.x + r.width) / w
        texy1 = r.y / h
        texy2 = (r.y + r.height) / h
        self.mapping[handle] = (r.x, r.y, r.width, r.height, texx1, texy1, texx2, texy2, textureindex)
      
    def getTextSize(self, text):
        """
        Returns the width and height of a text. All line breaking characters ('\\n' etc.) are ignored, so
        height is always the height of one line. 
        """
        mapping = self.mapping
        w = 0
        for c in text:
            try:
                w += mapping[c][2]
            except KeyError:
                w += self.missingWidth 
        return w, self.textHeight
     
    def getCharSize(self, char):
        """Returns the width and height of a character."""
        try:
            return self.mapping[char][2], self.textHeight
        except KeyError:
            return self.missingWidth, self.textHeight
     
    def begin(self):
        """Prepares the sprite for drawing."""
        filter = False
        colorkey = (0, 0, 0, 0)
        
        screen = self.device.getScreenDesc()
        
        effect = self.effect
        effect.set("screenSize", (screen.width, screen.height))
        effect.set("spriteTexture", self.textureView)
        effect.set("useFilter", filter)
        colorKey = [x / 255.0 for x in colorkey]
        effect.set("colorKey", colorKey)
        effect.apply(0, 0)

        self.device.setScissorRects([(0, 0, screen.width, screen.height)])
        self.device.setInputLayout(self.inputLayout)
        self.device.setPrimitiveTopology(PRIMITIVE_TOPOLOGY_POINTLIST)

        self.buffer.map(MAP_WRITE_DISCARD)

    def end(self):
        """Flushes all pending operations and ends rendering."""
        self.flush()
        self.buffer.unmap() #Flush maps it.
        self.device.restoreDepthStencilState()
        self.device.restoreBlendState()
        #self.device.restoreRasterizerState()
     
    def _findWordEnd(self, text, i):
        counter = i
        while i < len(text):
            char = text[i]
            if self._isSeparator(char):
                break
            counter += 1
            i += 1
        return counter
   
    def _createTextQuad(self, x, y, char, useitalic, color, scaling, gradient):
        if not char in self.mapping:
            char = "?"
        
        d = self.mapping[char]
        t = d[4:]
        W = d[2] * scaling
        H = d[3] * scaling
        
        if char.isspace():
            #Skip it. Are there any spaces that have visible glyphs?
            return W
        
        italic = 0
        if useitalic:
            #Cheap trick, but better than nothing.
            italic = int(self.textHeight * scaling * 0.33)
        
        p = (x, y, W, H) + color + t + (italic, 0, 0, gradient, 0)
        self.buffer.append(p)

        self._checkOverflow()
        return W 


    def _createLine(self, r, color, mod, scaling):
        liney = (self.textHeight * mod) * scaling
        h = max(self.textHeight * 0.05 * scaling, 1) 
        
        rect = (r[0], r[1] + liney, r[2] - r[0], h)
        p = rect + color + self.whitePixel + (0, 0, 0, 1, 0)
        self.buffer.append(p)

        self._checkOverflow()
        
    def _flushLines(self, x, y, underline, strikeout, color, scaling):
        if underline:
            assert(len(underline) < 4)
            self._createLine(underline + (x, y), color, 0.9, scaling) 
        if strikeout: 
            assert(len(strikeout) < 4)
            self._createLine(strikeout + (x, y), color, 0.55, scaling) 
 
    def flush(self):
        """Flushes all pending operations."""
        bufLen = len(self.buffer)
        if bufLen > 0:
            #XXX Unmapping, rendering and mapping can be slow.
            self.buffer.unmap()
            self.device.setVertexBuffers([self.buffer])
            self.device.draw(bufLen, 0)
            self.buffer.map(MAP_WRITE_DISCARD)
            
    def _checkOverflow(self):
        #Worst case is ~6, but double it.
        GROWMAX = 12
        if len(self.buffer) + GROWMAX > self.buffer.capacity():
            #Buffer can oveflow on the next iteration, flush it.
            self.flush() 
        
    def _isSeparator(self, char):
        # Pd = Punctuation, dash 
        return char.isspace() or unicodedata.category(STR(char)) == "Pd" #XXX STR 2.6 compat
        
    def drawRect(self, x, y, w, h, color=None, texture=None, bordercolor=None, bordersize=0, gradient=1, flip=0, rotation=0):
        """
        :param x: Starting x-coordinate.
        :param y: Starting y-coordinate.
        :param w: Width of the rectangle.
        :param h: Height of the rectangle.
        :param color: Fill color for the rectangle in RGBA-order, values can be from 0.0 to 1.0. If this is None the rectangle will 
            not be filled. If ``texture`` is given this color (if not None) is used to modify texture's color instead of filling the rectangle.
        :param texture: A string handle which indentifies a texture (eg. from :meth:`loadTexture` or :meth:`updateTexture`).
            If this is None the rectangle will not be textured. 
        :param bordercolor: Border color for the rectangle in RGBA-order.
        :param bordersize: Width of the rectangle's border. If 0 no border is drawn.
        :param gradient: Used to create a vertical color gradient by multiplying the fill color. 1.0 means no gradient.
        :param flip: How to "flip" the textured image. 0, FLIP_X, FLIP_Y or FLIP_BOTH.
        :param rotation: How much to rotate the rectangle in radians. The rectangle is rotated around it's center. Note
            that ``bordersize`` must be 0 if this is used.
        
        Draws a rectangle. Note that you can use keyword aguments so you don't have to pass all parameters if
        you just want to rotate a rectangle. ::
        
            s.begin()
            #Draws a red rectangle with no fill, only borders.
            s.drawRect(10, 10, 100, 100, None, None, (1, 0, 0, 1), 5)
            #Draws a red, rotated, filled rectangle.
            s.drawRect(200, 200, 75, 50, (1, 0, 0, 1), rotation=math.radians(45))
            #Draws a filled, half-transparent and yellow rectangle with a opaque green border.
            s.drawRect(50, 50, 25, 25, (1, 1, 0, 0.5), None, (0, 1, 0, 1), 2)
            #Draws a slightly transparent textured rectangle. 
            s.drawRect(100, 50, 50, 50, (1, 1, 1, 0.75), "MYIMAGE")
            s.end()
        """
        self._checkOverflow() 
        
        if bordercolor is None:
            bordercolor = (1, 1, 1, 1)
        
        texindex = 0
        border = bordersize
        if border > 0:
            #Create border "lines".
            top = (x, y, w, border)
            right = (x + w - border, y + border, border, h - border * 2)
            left = (x, y + border, border, h - border * 2)
            bottom = (x, y + h - border, w, border)
            for rect in (top, right, left, bottom):
                p = rect + bordercolor + self.whitePixel + (0, texindex, 1, 1, rotation)
                self.buffer.append(p)

        if color or texture:
            #Fill the rect.
            areatex = self.whitePixel

            if not color:
                color = (1, 1, 1, 1)
            
            if texture:
                coords = self.mapping[texture]
                areatex = coords[4:8]
                texindex = coords[8]

                #fill = (1,1,1,1)
                #gradient = 0.6 # XXX XXX remove this.

                #Flip texture coordinates.
                if flip & FLIP_X:
                    areatex = (areatex[2], areatex[1], areatex[0], areatex[3])
                if flip & FLIP_Y:
                    areatex = (areatex[0], areatex[3], areatex[2], areatex[1])
                    
            rect = (x + border, y + border, w - border * 2, h - border * 2)
            p = rect + color + areatex + (0, texindex, 1, gradient, rotation)
            self.buffer.append(p)
               
               
    def drawText(self, text, x, y, w=0, h=0, color=(1, 1, 1, 1), flags=0, xbase=None, scaling=1, gradient=1):
        """
        :param text: Text to be drawn.
        :type text: str or unicode
        :param x: Starting x-coordinate.
        :param y: Starting y-coordinate.
        :param w: Maximum width of the area. If this is 0 no word wrapping is performed.
        :param h: Maximum height of the area. 0 means no limit.
        :param color: Color of the text in RGBA-order, values can be from 0.0 to 1.0
        :param flags: A combination of :ref:`style flags <TextFlags>`.
        :param xbase: This affects where (in pixels) lines following the first one will be placed in x-axis. 
            Useful when drawing continuous text with many drawText() calls. If None it is assumed to be equal to ``x``.
        :param scaling: How much characters are scaled. Large deviations from 1.0 tend to look bad. 
            Usually it is best to use integer values (2, 3, 4 etc.).
        :type scaling: int or float
        :param gradient: Used to create a vertical color gradient by multiplying the color. 1.0 means no gradient.
            
        :returns: Coordinates indicating where the drawing stopped. This is useful if you want to 
            draw some other text correctly aligned with this one - you can use these coordinates 
            and ``xbase`` with future drawText()-calls.
        
        Draws text. Newline characters are respected (unless TEXT_SINGLELINE is used). This method must be called 
        between :meth:`~d3d11x.Sprite.begin` and :meth:`~d3d11x.Sprite.end` calls. Unknown characters 
        are drawn as '?'-characters. ::
        
            sprite.begin()
            sprite.drawText("Hello world!", 10, 10)
            sprite.drawText("This is a long string that will be word wrapped (width is set to 75).", 10, 100, 75)
            sprite.drawText("Some red, italic and alpha blended text with an underline.", 10, 150, 
                color=(1.0, 0.0, 0.0, 0.75), flags=TEXT_ITALIC|TEXT_UNDERLINE)
            sprite.end()
        """
        if flags & TEXT_XCENTER:
            assert(flags & TEXT_SINGLELINE and w != 0)
            size = self.getTextSize(text)
            x = x + w // 2 - size[0] // 2
        if flags & TEXT_YCENTER:
            assert(flags & TEXT_SINGLELINE and h != 0)
            y = y + h // 2 - self.textHeight // 2
    
        xorginal = x
        yorginal = y
        previous = "x" 
        xoffset = xbase
        if xoffset is None:
            xoffset = x
            xbase = x
        
        #flags |= TEXT_ITALIC | TEXT_UNDERLINE | TEXT_STRIKEOUT #| TEXT_SINGLELINE
        
        singleline = bool(flags & TEXT_SINGLELINE)
        italic = bool(flags & TEXT_ITALIC)
        underline = None 
        strikeout = None
        didLineBreak = True
        lineCount = 0
        lineStart = x #XXX does not work 100%, see hmap sample and 'render a simple' - linebreak before 'a'
        rightEnd = xorginal + w #- self.missingWidth # missingWidth is not that good...
        bottomEnd = yorginal + h #- self.textHeight
        
        for i, char in enumerate(text):
            isSeparator = self._isSeparator(char)
        
            if didLineBreak:
                if lineCount > 0:
                    xbase =  xoffset
                lineCount += 1

                if not isSeparator: 
                    #First character on a line.
                    if flags & TEXT_UNDERLINE:
                        underline = (lineStart, y) 
                    if flags & TEXT_STRIKEOUT:
                        strikeout = (lineStart, y)  
                    didLineBreak = False
                else:
                    lineStart = x
                
            if w != 0 and not isSeparator and self._isSeparator(previous) and not singleline:
                #This character starts a word.
                wordEnd = self._findWordEnd(text, i)
                wordWidth = self.getTextSize(text[i:wordEnd])[0] * scaling

                if x + wordWidth > xbase + w:
                    #Overflow, advance to the next line.
                    self._flushLines(x, y, underline, strikeout, color, scaling)
                    x = xbase 
                    y += self.textHeight * scaling 
                    didLineBreak = True
                    underline = None  
                    strikeout = None
                    lineStart = x
    
            previous = char
        
            lineBreak = False
            if w != 0:
                charWidth = self.getCharSize(char)[0]
                if x + charWidth > rightEnd:
                    if singleline:
                        #Out of x-bound, stop everything
                        break 
                    else:
                        lineBreak = True
        
            if char == "\n" or lineBreak: 
                if singleline:
                    #Ignore newlines.
                    x += self.missingWidth
                    continue

                #Advance to the next line, don't draw anything.
                self._flushLines(x, y, underline, strikeout, color, scaling)
                x = xbase 
                y += self.textHeight * scaling
                didLineBreak = True
                underline = None  
                strikeout = None
                if not lineBreak:
                    continue
                char = " "

            if h != 0 and y >= bottomEnd:
                #Out of y-bound, stop everything.
                break
                    
            x += self._createTextQuad(x, y, char, italic, color, scaling, gradient)
        
        self._flushLines(x, y, underline, strikeout, color, scaling)
        return int(x), int(y) #Return the bounding rect too? Floating point can be wrong, use ceil()?
      
      
class Camera(object):

    #: Current position of the camera.
    pos = None
    #: Current (normalized) viewing direction of the camera.
    dir = None

    def __init__(self, position=(0, 15, -20), lookat=(0, 0, 0), speed=1.0):
        """
        :param position: Starting position vector.
        :param lookat: Starting look-at point.
        :param speed: Relative speed of the camera movement.
    
        Creates a new Camera.
        """
        self.setView(position, lookat)
        self.speed = speed 
        self.speedOrginal = self.speed
        self.leftDown = False
        self.leftPoint = None
        self.targetDrive = None
        
    def setView(self, position, lookat):
        """Sets the position and viewing direction."""
        self.pos = d3d11.Vector(position)
        self.dir = (d3d11.Vector(lookat) - self.pos).normalize()
        
    def drive(self, target, lookat):
        """
        :param position: Final target position for the camera drive.
        :param tracking: The position which the camera tracks during the drive.
        
        Starts a camera "drive" from camera's current location to the target position. During this
        time user input is ignored. When the camera has reached the target position the drive
        is stopped and user resumes control.
        """
        distance = self.pos.distance(target)
        if distance > 0.0:
            self.targetDrive = (d3d11.Vector(target), d3d11.Vector(lookat), distance)
        else:
            self.setView(target, lookat)
        
    def driveStop(self):
        """Stops the :meth:`~Camera.drive`."""
        self.targetDrive = None
        
    def isDriving(self):
        """Returns True if the camera is currently in drive mode."""
        return self.targetDrive is not None
        
    def onUpdate(self, frameTime):
        """
        :param frameTime: Time passed since the last update. This is used to adjust movement speed.
    
        Should be called once per frame (unless paused etc). This updates cameras position and
        checks if the user is pressing any movement keys. 
        """
        if d3d11.isKeyDown(VK_SHIFT) and not self.isDriving():
            self.speed = self.speedOrginal * 2.0
        else:
            self.speed = self.speedOrginal
    
        #Adjust to FPS. Assume average is around 60.
        self.speed = (frameTime / (1.0 / 60.0)) * self.speed
    
        if self.targetDrive is not None:
            #Driving camera.
            target, lookat, driveDistance = self.targetDrive
            
            moveDir = target - self.pos
            oldDistance = moveDir.length()
            self.pos += moveDir.normalize() * self.speed
            newDistance = self.pos.distance(target)
            
            newDir = (lookat - self.pos).normalize()
            #The nearer we are, the more we should force the direction.
            dirSpeed = min((1.0 - newDistance / driveDistance) * self.speed, 1.0)
            self.dir = self.dir.lerp(newDir, dirSpeed).normalize()
            
            if (self.pos - target).length() < 0.01 or newDistance > oldDistance:
                #Near enough or going past the target, stop.
                self.pos = target
                self.dir = newDir
                self.driveStop()
            return
    
        keyDown = d3d11.isKeyDown
    
        if keyDown(ord("W")) or keyDown(VK_UP):
            self.pos += self.dir * self.speed
        if keyDown(ord("S")) or keyDown(VK_DOWN):
            self.pos -= self.dir * self.speed
        if keyDown(ord("A")) or keyDown(VK_LEFT):
            crossed = self.dir.cross(d3d11.Vector(0, 1, 0))
            self.pos += crossed * self.speed
        if keyDown(ord("D")) or keyDown(VK_RIGHT):
            crossed = self.dir.cross(d3d11.Vector(0, 1, 0))
            self.pos -= crossed * self.speed
        
    def getViewMatrix(self):
        m = d3d11.Matrix()
        m.lookAt(self.pos, self.pos + self.dir, (0, 1, 0))
        return m
        
    def onMessage(self, msg):
        if self.isDriving():
            return False
    
        if msg.code == WM_MOUSEMOVE and self.leftDown:
            mousePos = msg.x, msg.y 
            xdelta = mousePos[0] - self.leftPoint[0]
            ydelta = mousePos[1] - self.leftPoint[1] 
        
            turnSpeed = 0.005 #* self.speed #Don't use speed when looking around.
            mrot = d3d11.Matrix()
            mrot.rotate((0.0, xdelta * turnSpeed, 0.0))
            newDir = mrot.transformVector(self.dir)

            #Restrict the view angle so that you can't
            #look (relatively) directly up or down.
            allowlook = False
            if self.dir.y > -0.9 and ydelta >= 0:
                allowlook = True
            if self.dir.y < 0.9 and ydelta <= 0: 
                allowlook = True
            if allowlook:
                newDir = (newDir + d3d11.Vector(0, -ydelta * turnSpeed, 0))
                
            self.dir = newDir.normalize()
            
            self.leftPoint = mousePos
            return True #Handled.
        elif msg.code == WM_LBUTTONDOWN:
            self.leftDown = True
            self.leftPoint = msg.x, msg.y 
            return True #Handled.
        elif msg.code == WM_LBUTTONUP:
            self.leftDown = False
            self.leftPoint = None
            return True #Handled.
        elif msg.code == WM_MOUSEWHEEL:
            delta = msg.wheel * self.speed
            self.pos = d3d11.Vector(self.pos.x, self.pos.y + delta * 1.5, self.pos.z)
            return True #Handled.

        return False
 
_noHWSupport = """No hardware support for Direct 3D %i.%i - fallback to WARP software device."""
       
_onCreateError = """\
There was an error initializing this application. It is possible that some required \
D3D hardware feature is not supported or something else went wrong. This application will now terminate.

Error message: 

%s"""
      
_controlsHelp = """

Frame controls:
    P - Pause
    F8 - Toggle fullscreen
  
Statistics:
    Adapter: %s (~%i MB)
    FPS: ~%i
    Screen size: %ix%i
    V-sync: %s"""
       
class Frame(object):
    minFeatureLevel = FEATURE_LEVEL_10_0
    iconpath = getResourceDir("Textures", "x.ico")

    #: Default device created by the Frame.
    device = None
    #: How long it took to process previous frame in seconds.
    frameTime = None
    #:A tuple which will be used to set the resolution when changing from windowed to fullscreen mode.
    fullscreenSize = None
    #: True if the application is currently paused.
    paused = None
    #: Time in seconds since the first call to time.clock()
    time = None
    #: Argument passed to :meth:`d3d11.Device.present`.
    verticalSync = None
    #: Default window created by the Frame.
    window = None
    #: A tuple which will be used to set the window size when changing from fullscreen to windowed mode.
    windowedSize = None
    
    def __init__(self, title, helpText="No help provided."):
        """Constucts a new Frame."""
        self.title = title
        self.window = d3d11.Window()
        self.window.setRect((100, 100, 800, 600))
        self.window.setTitle(title)
        self.window.setIcon(self.iconpath)
        self.window.show(SW_SHOW)

        adapterIndex = 0 #Default.
        adapterInfo = d3d11.enumAdapters()[adapterIndex]
        
        #Try to create a device, hardware version first.
        self.device = None
        for i, flag in enumerate((DRIVER_TYPE_HARDWARE, DRIVER_TYPE_WARP)): 
            try:
                device = d3d11.Device(self.window, flag, adapterIndex) 
                flevel = device.getFeatureLevel()
                if flevel >= self.minFeatureLevel:
                    #Ok, got a valid device.
                    self.device = device
                    if flag == DRIVER_TYPE_WARP:
                        #Notify the user that we are running on a software device.
                        self.popup(_noHWSupport % featureLevel(flevel)) 
                        adapterInfo = ("Software WARP", 0, 0, 0, 0, 0, 0, 0)
                    break 
                else:
                    #Keep looking.
                    device.release()
            except:
                pass

        if self.device is None:
            #No device, no party.
           self.popup("No valid Direct3D device found. Terminating the application.") 
           self.exit()
        
        self.time = 0.0
        self.frameTime = 0.00001
        self.verticalSync = 1
        self.paused = False
        self.fullscreenSize = (0, 0)
        self.windowedSize = (800, 600)
        self.showHelp = True
        self._helpSprite = None 
        self._helpText = helpText.strip().replace("\n", " ") + _controlsHelp
        self._helpVisible = False
        self._minimized = False
        self._adapterName = adapterInfo[0]
        self._adapterMemory = adapterInfo[5] // 1048576 #About.
        self._takeScreenshot = None
        
        try:
            if self.showHelp:
                self._helpSprite = Sprite(self.device, "Arial", 18) 
            
            self.onCreate()
            self.onResize()
        except SystemExit:
            raise
        except:
            self.popup(_onCreateError % str(sys.exc_info()[1]))
            raise
        
    def popup(self, text, mode=0):
        return d3d11.messageBox(self.window, text, self.title, mode | 0x00000030)
        
    def yesNo(self, text):
        return self.popup(text, 0x00000004)
        
    def createLookAt(self, eye, point):
        """A convenience method which creates a view matrix."""
        m = d3d11.Matrix()
        m.lookAt(eye, point, (0, 1, 0))
        return m
        
    def createProjection(self, fov, zmin, zmax):
        """A convenience method which creates a projection matrix. Note that ``fov``
        should be in degrees."""
        info = self.device.getScreenDesc()
        aspectRatio = float(info.width) / info.height
        m = d3d11.Matrix()
        m.perspectiveFov(math.radians(fov), aspectRatio, zmin, zmax)
        return m
        
    def loadTexture(self, name):
        """
        A convenience method which loads a texture from the default texture directory. 
        
        This is included to avoid ugly directory joining and hard coded paths in samples. It also makes
        easy to add any caching etc. if required. For example when using the :meth:`loadTextureView` this::
        
            resourceDir = d3d11x.getResourceDir("Textures")
            texture = d3d11.View(d3d11.Texture(os.path.join(resourceDir, "example.dds")))
            
        can be written (much more cleanly) as::
        
            texture = self.loadTextureView("example.dds")
        """
        full = getResourceDir("Textures", name)
        return d3d11.Texture(full)
        
    def loadTextureView(self, name):
        """A convenience method for loading texture views."""
        return d3d11.View(self.loadTexture(name))
        
    def takeScreenshot(self, path, format):
        """
        Stores the arguments and when the next rendering pass is done saves the default
        render target into a file. Both arguments will be passed to :meth:`d3d11.Texture.save`.
        """
        self._takeScreenshot = (path, format)
        
    def _reallyTakeScreenshot(self):
        self.device.flush() #Just in case.
        rt = self.device.getDefaultRT() #Assume default RT.
        args = (None, ) + rt.getDesc()
        temp = d3d11.Texture(*args)
        temp.resolve(rt)
        temp.save(*self._takeScreenshot)
        rt.release()
        self._takeScreenshot = None
        
    def toggleFullscreen(self):
        """Toggles between windowed and fullscreen mode."""
        info = self.device.getScreenDesc()
        toFullscreen = info.windowed #If windowed now, go fullscreen.
        if toFullscreen:
            size = self.fullscreenSize
        else:
            size = self.windowedSize
        self.device.setFullscreenState(toFullscreen, size[0], size[1])
        
        if not toFullscreen:
            self.window.setRect((100, 100, self.windowedSize[0], self.windowedSize[1]))
        
    def _handleMessages(self):
        wmSize = False
        
        for msg in self.window.getMessages():
            code = msg.code
            if code == WM_DESTROY:
                #Exit immediately, window has been destroyed.
                self.exit()
            
            if self.onMessage(msg):
                continue
              
            if isMouseMessage(msg):
                self.onMouse(msg)
            elif code == WM_CHAR: 
                if msg.char in ("p", "P"): 
                    self.paused = not self.paused
                self.onChar(msg)
            elif isKeyMessage(msg):
                if code == WM_KEYUP and msg.vk == VK_F8:
                    self.toggleFullscreen()
                    wmSize = True
                if code == WM_KEYDOWN and msg.vk == VK_F1:
                    self._helpVisible = not self._helpVisible
                else:
                    self.onKey(msg)
            elif code == WM_CLOSE:  
                #Respond to this too.
                self.exit()
            elif code == WM_SIZE:
                if msg.wparam == 1:
                    #Minimized
                    self._minimized = True
                else:
                    #Shown
                    self._minimized = False
                wmSize = True
                 
        if wmSize:
            #Only call this once, minor optimization. When the user resizes
            #a window, you typically reveice dozens of WM_SIZE-messages.
            self.onResize()
                 
    def _internalMainLoop(self):
        while 1:
            if self._minimized:
                #Wait until restored.
                self._handleMessages()
                time.sleep(0.01)
                continue
        
            start = time.clock()
            
            self._handleMessages()
            if not self.paused:
                self.onUpdate()
            
            self.device.setRenderTargetsDefault()
            self.onRender()
            
            if self.showHelp:
                self._drawHelp()
            
            if self._takeScreenshot:
                self._reallyTakeScreenshot()
            
            self.device.present(self.verticalSync)
            
            if not self.paused:
                self.time = start
                #Clamp the value.
                self.frameTime = min(max(time.clock() - self.time, 0.0), 0.1)
             
    def _drawHelp(self):
        text = "Press F1 for help." 
        if self._helpVisible:
            info = self.device.getScreenDesc()
            fps = int(1.0 / self.frameTime) #An estimation.
            text = "Help (Press F1 to hide):\n\n" +  (self._helpText % (self._adapterName,
                self._adapterMemory, fps, info.width, info.height, self.verticalSync > 0))
        
        info = self.device.getScreenDesc()
        self._helpSprite.begin()
        self._helpSprite.drawText(text, 10, 10, int(info.width * 0.75), info.height - 10, color=(1, 1, 0, 1))
        self._helpSprite.end()
        
    def _forceWindowed(self):
        #Switch to windowed mode.
        if self.device and not self.device.getScreenDesc().windowed:
            self.toggleFullscreen()
        
    def exit(self):
        """Perfoms some cleanup and calls sys.exit() 
        (which in turn raises a SystemExit exception)."""
        self._forceWindowed()
        self.onExit()
        Resource.clearCacheAll()
        sys.exit()
         
    def mainloop(self):
        """Starts the mainloop which runs until the window is closed or
        the loop is terminated in some other way."""
        try:
            self._internalMainLoop()
        except:
            self._forceWindowed()
            raise
         
    #Callbacks
         
    def onResize(self):
        """Called when the window area or position has changed."""
        pass
         
    def onCreate(self):
        """Called once when when the Frame has initialized itself."""
        pass
        
    def onRender(self):
        """Called when the application should render it's contents."""
        pass
        
    def onUpdate(self):
        """Called when the application should do it's per-frame computations. This is not called
        when the Frame is paused or minimized."""
        pass
        
    def onExit(self):
        pass
        
    #Message callbacks
        
    def onMessage(self, event):
        """
        Called first for each message. If this method returns True, Frame assumes
        that the message was handled and does no further processing. Otherwise the
        message is processed normally and then forwarded to the appropriate callback (if any).
        """
        return False
        
    def onKey(self, event):
        """Called when the user presses, releases or holds down a key."""
        pass
        
    def onChar(self, event):
        """
        Called when the user has pressed a character key. This is a convenience callback, 
        :meth:`~Frame.onKey` reveices keyboard messages too. ::
        
            def onChar(self, event):
                if event.char in ("x", "X"):
                    #Upper- and lower-case.
                    print("You typed 'x'")
        """
        pass
        
    def onMouse(self, event):
        """
        Called when a mouse event has occurred. ::
        
            #Override the default onMouse()-handler.
            def onMouse(self, event):
                if event.code == WM_LBUTTONDOWN:
                    #User pressed the left mouse button.
                    print("You clicked at x=%i, y=%i" % (event.x, event.y))
        """
        pass
        
        
        
        