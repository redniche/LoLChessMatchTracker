
# Copyright (C) 2010, Heikki Salo
# All rights reserved.
#
# Distributed under the BSD license:
# http://www.opensource.org/licenses/bsd-license.php

import sys
import struct
import collections

from d3d11c import *

#Some format, TODO: add more!
formatMappings10 = {
    FORMAT_R8G8B8A8_UNORM : ("4B", "rgba"),
    FORMAT_B8G8R8A8_UNORM : ("4B", "bgra"),
}

#Header flags
DDSD_CAPS = 0x1 
DDSD_HEIGHT = 0x2 
DDSD_WIDTH = 0x4 
DDSD_PITCH = 0x8 
DDSD_PIXELFORMAT = 0x1000 
DDSD_MIPMAPCOUNT = 0x20000 
DDSD_LINEARSIZE = 0x80000 
DDSD_DEPTH = 0x800000

#Pixel format flags
DDPF_ALPHAPIXELS = 0x1
DDPF_ALPHA = 0x2
DDPF_FOURCC = 0x4
DDPF_RGB = 0x40
DDPF_YUV = 0x200
DDPF_LUMINANCE = 0x20000

#Header 10
D3D10_RESOURCE_DIMENSION_UNKNOWN = 0
D3D10_RESOURCE_DIMENSION_BUFFER = 1
D3D10_RESOURCE_DIMENSION_TEXTURE1D = 2
D3D10_RESOURCE_DIMENSION_TEXTURE2D = 3
D3D10_RESOURCE_DIMENSION_TEXTURE3D = 4

#dwReserved1 and ddpf are ignored.
DDS_HEADER = collections.namedtuple("DDS_HEADER", """dwSize dwFlags dwHeight dwWidth dwLinearSize dwDepth 
    dwMipMapCount dwCaps dwCaps2 dwCaps3 dwCaps4 dwReserved2""")
 
DDS_HEADER_DXT10 = collections.namedtuple("DDS_HEADER_DXT10", """dxgiFormat resourceDimension miscFlag arraySize reserved""")
 
DDS_PIXELFORMAT = collections.namedtuple("DDS_PIXELFORMAT", """dwSize dwFlags dwFourCC dwRGBBitCount 
    dwRBitMask dwGBitMask dwBBitMask dwABitMask""")
    
class RGBA:
    def __init__(self, r=0, g=0, b=0, a=0):
        self.r = r
        self.g = g
        self.b = b
        self.a = a
        
    def __str__(self):
        return "RGBA(%.2f, %.2f, %.2f, %.2f)" % (self.r, self.g, self.b, self.a)
        
    def __getitem__(self, index):
        return (self.r, self.g, self.b, self.a)[index]
        
    
def make4CC(code):
    assert(len(code) == 4)
    return ord(code[0]) | (ord(code[1]) << 8) | (ord(code[2]) << 16) | (ord(code[3]) << 24)
    
def get4CC(code):
    assert(code <= 0xffffffff)
    a, b, c, d = (code >> 24) & 0xff, (code >> 16) & 0xff, (code >> 8) & 0xff, (code & 0xff)
    return  chr(d) + chr(c) + chr(b) + chr(a)
    
def B(text):
    return text.encode("latin-1")
    
def check(value, msg="Check failed"):
    if not value:
       raise RuntimeError(msg)
    
def dwWrite(f, dwValue):
    f.write(struct.pack("L", dwValue))
    
    
class DDSFile:
    def __init__(self, path):
        self.f = f = open(path, "rb")
        check(f.read(4) == B("DDS "), "Invalid DDS magic number")
            
        count = str(124 // 4)
        tmpheader = struct.unpack(count + "L", f.read(124))

        PIXELFORMAT = DDS_PIXELFORMAT(*tmpheader[18:18+8])
        HEADER = DDS_HEADER(*(tmpheader[:8] + tmpheader[8+11+8:]))
            
        check(HEADER.dwSize == 124, "Invalid header size")
        check(PIXELFORMAT.dwSize == 32, "Invalid pixel header size")
            
        self.HEADER = HEADER
        self.PIXELFORMAT = PIXELFORMAT

        HEADER_DXT10 = None
        if PIXELFORMAT.dwFlags & DDPF_FOURCC and PIXELFORMAT.dwFourCC == make4CC("DX10"):
            #This has a D3D 10 header
            h10 = struct.unpack("5L", f.read(5 * 4))
            HEADER_DXT10 = DDS_HEADER_DXT10(*h10)
            check(HEADER_DXT10.resourceDimension == D3D10_RESOURCE_DIMENSION_TEXTURE2D, "Not a 2D texture")
            
        self.HEADER_DXT10 = HEADER_DXT10

        self.validate()
        
    def getHeaderSize(self):
        headersize = 4 + 124 
        if self.isVersion10():
            headersize += 5 * 4
        return headersize
        
    def readSurface(self):
        self.f.seek(self.getHeaderSize())
    
        formatStr, order = self._itemFormatOrder()
        formatSize = struct.calcsize(formatStr)
        
        pixels = []
        for y in range(self.HEADER.dwHeight):
            pixels.append([])
            for x in range(self.HEADER.dwWidth):
                data = self.f.read(formatSize)
                rgba = RGBA()
                for i, x in enumerate(struct.unpack(formatStr, data)):
                    setattr(rgba, order[i], x)
                pixels[-1].append(rgba)
        
        return pixels
        
    def save(self, path, data, savealpha=False):
        out = open(path, "wb")
        out.write(B("DDS "))
        
        formatStr = self.getItemFormat()
        byteSize = struct.calcsize(formatStr)
        width = len(data[0])
        height = len(data)
        
        #DDS_HEADER
        dwWrite(out, 124) #dwSize
        dwWrite(out, DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PITCH | DDSD_PIXELFORMAT) #dwFlags
        dwWrite(out, height) #dwHeight
        dwWrite(out, width) #dwWidth
        dwWrite(out, width * byteSize) #dwLinearSize 
        dwWrite(out, 0) #dwDepth
        dwWrite(out, 0) #dwMipMapCount 
        for i in range(11):
            dwWrite(out, 0) #dwReserved1
           
        pixelFlags = DDPF_RGB
        alphaMask = 0
        if savealpha:
            pixelFlags |= DDPF_ALPHAPIXELS
            alphaMask = 0xff000000
            
        #DDS_PIXELFORMAT (always ARGB8)
        dwWrite(out, 32) #dwSize
        dwWrite(out, pixelFlags) #dwFlags 
        dwWrite(out, 0) #dwFourCC 
        dwWrite(out, 8 * 4) #dwRGBBitCount 
        dwWrite(out, 0x00ff0000) #dwRBitMask 
        dwWrite(out, 0x0000ff00) #dwGBitMask  
        dwWrite(out, 0x000000ff) #dwBBitMask 
        dwWrite(out, alphaMask) #dwABitMask 
        
        #DDS_HEADER continues
        dwWrite(out, 0x1000) #dwCaps - Texture
        dwWrite(out, 0) #dwCaps2  
        dwWrite(out, 0) #dwCaps3    
        dwWrite(out, 0) #dwCaps4     
        dwWrite(out, 0) #dwReserved2 
        check(out.tell() == 4 + 124)

        for y in data:
            check(len(y) == width)
            for rgba in y:
                pixel = (rgba.b, rgba.g, rgba.r, rgba.a)
                raw = struct.pack(formatStr, *pixel)
                out.write(raw)
        
    def _itemFormatOrder(self):
        if self.isVersion10():
            dxgiformat = self.HEADER_DXT10.dxgiFormat
            if dxgiformat in formatMappings10:
                return formatMappings10[dxgiformat]
        else:
            pass
             
        return (None, None)
        
    def getItemFormat(self):
        return self._itemFormatOrder()[0]
        
    def validate(self):
        for required in (DDSD_HEIGHT, DDSD_WIDTH):
            check(self.HEADER.dwFlags & required, "Required flag not present")
            
    def isCompressed(self):
        if self.HEADER_DXT10:
            return True #XXX Check the format...
        else:
            return bool(self.PIXELFORMAT.dwFlags & DDPF_FOURCC)
            
    def isVersion10(self):
        return self.HEADER_DXT10 is not None
        
    def arraySize(self):
        if self.HEADER_DXT10:
            return self.HEADER_DXT10.arraySize
        return 1
        
    def size(self):
        return self.HEADER.dwWidth, self.HEADER.dwHeight
        
        
if __name__ == "__main__":
    if len(sys.argv) > 1:
        f = DDSFile(sys.argv[1])
        print("File: '%s'" % sys.argv[1])
        print("Size: %ix%i" % f.size())
        print("Mipmaps: %i" % f.HEADER.dwMipMapCount)
        print("Has a D3D10 header: %s" % f.isVersion10())
        if f.isVersion10():
            print("Array size: %i" % f.HEADER_DXT10.arraySize)
        
        print("Converting...")
        data = f.readSurface()
        f.save(sys.argv[1] + "_out.dds", data)
        
    else:
        #XXX print usage help.
        pass
